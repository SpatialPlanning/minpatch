<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Boundary penalty in MinPatch • minpatch</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Boundary penalty in MinPatch">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-primary" data-bs-theme="dark" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">minpatch</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../articles/minpatch.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/boundary-penalty.html">Boundary penalty in MinPatch</a></li>
    <li><a class="dropdown-item" href="../articles/minpatch-oceandatr-Seychelles.html">Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)</a></li>
    <li><a class="dropdown-item" href="../articles/minpatchTasmania.html">MinPatch in Tasmania</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/SpatialPlanning/minpatch/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Boundary penalty in MinPatch</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/SpatialPlanning/minpatch/blob/HEAD/vignettes/boundary-penalty.Rmd" class="external-link"><code>vignettes/boundary-penalty.Rmd</code></a></small>
      <div class="d-none name"><code>boundary-penalty.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="overview">Overview<a class="anchor" aria-label="anchor" href="#overview"></a>
</h2>
<p><code>boundary_penalty</code> is an optional parameter that
discourages irregular (high-perimeter) patch shapes during <strong>Stage
3 (Simulated Whittling)</strong>. The key idea is that
<code>boundary_penalty</code> converts <strong>boundary length
(perimeter)</strong> into the same “currency” as planning-unit cost, so
MinPatch can trade off saving cost against creating more edge.</p>
<p>In practice:</p>
<ul>
<li><p>higher <code>boundary_penalty</code> → stronger preference for
smooth, compact patches (less edge)</p></li>
<li><p>lower <code>boundary_penalty</code> → more willingness to accept
jagged edges if they reduce planning-unit cos</p></li>
</ul>
</div>
<div class="section level2">
<h2 id="where-it-is-used-in-minpatch">Where it is used in MinPatch<a class="anchor" aria-label="anchor" href="#where-it-is-used-in-minpatch"></a>
</h2>
<p>MinPatch does <strong>not</strong> re-run the optimiser in Stage 3.
Instead, it tests removing one <strong>edge</strong> planning unit at a
time and accepts the removal only if:</p>
<ol style="list-style-type: decimal">
<li><p>Targets remain met</p></li>
<li><p>Minimum patch-size requirements remain met (including after
splits)</p></li>
<li><p>The boundary-penalised objective does <strong>not</strong>
increase (only if <code>boundary_penalty &gt; 0</code>)</p></li>
</ol>
<p>This means Stage 3 uses a <strong>local “delta” test</strong> (change
in objective) rather than solving a new optimisation problem.</p>
</div>
<div class="section level2">
<h2 id="decision-rule-the-thing-to-remember">Decision rule (the thing to remember)<a class="anchor" aria-label="anchor" href="#decision-rule-the-thing-to-remember"></a>
</h2>
<p>Conceptually, Stage 3 evaluates an objective of the form:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">Objective</mtext><mo>=</mo><mo>∑</mo><mo stretchy="false" form="prefix">(</mo><mtext mathvariant="normal">PU cost</mtext><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mtext mathvariant="normal">boundary_penalty</mtext><mo>×</mo><mo stretchy="false" form="prefix">(</mo><mtext mathvariant="normal">total perimeter</mtext><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\text{Objective} = \sum(\text{PU cost}) + \text{boundary_penalty} \times (\text{total perimeter})
</annotation></semantics></math></p>
<p>When testing removal of a single planning unit, the code computes a
local change:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mtext mathvariant="normal">Objective</mtext><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mtext mathvariant="normal">boundary_penalty</mtext><mo>×</mo><mi mathvariant="normal">Δ</mi><mtext mathvariant="normal">perimeter</mtext><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mtext mathvariant="normal">unit_cost</mtext></mrow><annotation encoding="application/x-tex"> \Delta \text{Objective} = (\text{boundary_penalty} \times \Delta \text{perimeter}) - \text{unit_cost} </annotation></semantics></math></p>
<p>- If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mtext mathvariant="normal">Objective</mtext><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\Delta \text{Objective} &gt; 0</annotation></semantics></math>
→ objective increased → <strong>block</strong> removal<br>
- If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mtext mathvariant="normal">Objective</mtext><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\Delta \text{Objective} \le 0</annotation></semantics></math>
→ objective stayed the same or decreased → <strong>allow</strong>
removal (assuming constraints pass)</p>
<div class="section level3">
<h3 id="why-this-looks-like-total_cost_change-in-the-code">Why this looks like “total_cost_change” in the code<a class="anchor" aria-label="anchor" href="#why-this-looks-like-total_cost_change-in-the-code"></a>
</h3>
<p>In the code, you’ll often see a value like:</p>
<p><code>total_cost_change = boundary_cost_change - unit_cost</code></p>
<p>That is exactly
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mtext mathvariant="normal">Objective</mtext></mrow><annotation encoding="application/x-tex">\Delta \text{Objective}</annotation></semantics></math>
written in code form:</p>
<ul>
<li><p><code>boundary_cost_change</code> corresponds to
<code>boundary_penalty × Δperimeter</code></p></li>
<li><p><code>unit_cost</code> is the cost you save by removing the
unit</p></li>
</ul>
<p>So: <code>total_cost_change</code> <strong>is the change in the
objective</strong>.</p>
</div>
</div>
<div class="section level2">
<h2 id="what-does-same-currency-as-cost-mean">What does “same currency as cost” mean?<a class="anchor" aria-label="anchor" href="#what-does-same-currency-as-cost-mean"></a>
</h2>
<p>The objective combines two different things:</p>
<ol style="list-style-type: decimal">
<li><p><strong>Planning-unit cost</strong> (whatever you choose:
dollars, area, opportunity cost, etc.)</p></li>
<li><p><strong>Perimeter</strong> (boundary length: km, m, or “edge
count” depending on your data)</p></li>
</ol>
<p>To add these together, <code>boundary_penalty</code> acts like a
<strong>conversion rate</strong>: it converts boundary length into “cost
units”.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">Objective</mtext><mo>=</mo><mo>∑</mo><mo stretchy="false" form="prefix">(</mo><mtext mathvariant="normal">PU cost</mtext><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mtext mathvariant="normal">boundary_penalty</mtext><mo>×</mo><mo stretchy="false" form="prefix">(</mo><mtext mathvariant="normal">total perimeter</mtext><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\text{Objective} = \sum(\text{PU cost}) + \text{boundary_penalty} \times (\text{total perimeter})</annotation></semantics></math></p>
<div class="section level3">
<h3 id="if-your-pu-cost-is-in-dollars">If your PU cost is in dollars<a class="anchor" aria-label="anchor" href="#if-your-pu-cost-is-in-dollars"></a>
</h3>
<ul>
<li><p>PU cost might be:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>$</mi><mi>/</mi><mtext mathvariant="normal">PU</mtext></mrow><annotation encoding="application/x-tex">\$ / \text{PU}</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>$</mi><mi>/</mi><msup><mtext mathvariant="normal">km</mtext><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\$ / \text{km}^2</annotation></semantics></math></p></li>
<li><p>perimeter is in km</p></li>
<li><p>so <code>boundary_penalty</code> behaves like <strong>dollars per
km of edge</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>$</mi><mi>/</mi><mtext mathvariant="normal">km</mtext></mrow><annotation encoding="application/x-tex">\$ / \text{km}</annotation></semantics></math></p></li>
</ul>
<p><strong>Interpretation:</strong><br><code>boundary_penalty</code> is the <em>price you are willing to
pay</em> to avoid 1 km of extra boundary.</p>
<p>Example: if <code>boundary_penalty = 2000</code>, then adding 1 km of
perimeter “costs” $2000 in the objective.</p>
</div>
<div class="section level3">
<h3 id="if-your-pu-cost-is-area">If your PU cost is area<a class="anchor" aria-label="anchor" href="#if-your-pu-cost-is-area"></a>
</h3>
<p>Sometimes “cost” is literally area (e.g., each PU cost = area in
km²). Then:</p>
<ul>
<li><p>PU cost is in km²</p></li>
<li><p>perimeter is in km</p></li>
<li><p><code>boundary_penalty</code> behaves like <strong>km² per
km</strong></p></li>
</ul>
<p>You can think of this as “equivalent area cost per km of edge”.</p>
<p><strong>Interpretation:</strong><br><code>boundary_penalty</code> tells you how much extra <em>area
cost</em> you are willing to accept to avoid 1 km of extra boundary.</p>
<p>So if <code>boundary_penalty = 0.5</code>, then an extra 1 km of edge
is treated like adding 0.5 km² of cost.</p>
</div>
<div class="section level3">
<h3 id="the-simplest-way-to-remember-it">The simplest way to remember it<a class="anchor" aria-label="anchor" href="#the-simplest-way-to-remember-it"></a>
</h3>
<ul>
<li><p><strong>unit_cost</strong> = the savings you get from removing a
PU</p></li>
<li><p><strong>boundary_penalty × Δperimeter</strong> = the “edge bill”
you pay (or save) when boundary changes</p></li>
</ul>
<p>And Stage 3 only removes a PU when:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mtext mathvariant="normal">Objective</mtext><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mtext mathvariant="normal">boundary_penalty</mtext><mo>×</mo><mi mathvariant="normal">Δ</mi><mtext mathvariant="normal">perimeter</mtext><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mtext mathvariant="normal">unit_cost</mtext><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex"> \Delta \text{Objective} = (\text{boundary_penalty} \times \Delta \text{perimeter}) - \text{unit_cost} \le 0 </annotation></semantics></math></p>
<p>So you can read it as:</p>
<blockquote>
<p>Only remove the PU if the edge bill doesn’t outweigh the cost
saved.</p>
</blockquote>
</div>
</div>
<div class="section level2">
<h2 id="worked-examples-with-explicit-total-perimeter">Worked examples (with explicit total perimeter)<a class="anchor" aria-label="anchor" href="#worked-examples-with-explicit-total-perimeter"></a>
</h2>
<p>Assumptions for both examples:</p>
<ul>
<li>4-neighbour adjacency (up/down/left/right)</li>
<li>each shared cell edge has length <strong>1 km</strong>
</li>
<li>
<code>total perimeter</code> is the perimeter of the <strong>whole
selected patch</strong> (in km)</li>
</ul>
<p>A very useful identity (grid perimeter change):</p>
<p>If a removed PU has
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math><strong>selected neighbours</strong> (0–4), then removing it changes
perimeter by:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mtext mathvariant="normal">perimeter</mtext><mo>=</mo><mi>−</mi><mn>4</mn><mo>+</mo><mn>2</mn><mi>k</mi></mrow><annotation encoding="application/x-tex">
\Delta \text{perimeter} = -4 + 2k
</annotation></semantics></math></p>
<p>So perimeter <strong>increases</strong> only when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≥</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">k \ge 3</annotation></semantics></math>
(i.e., the PU was “shielding” three selected neighbours).</p>
<hr>
<div class="section level3">
<h3 id="example-a-removing-an-edge-pu-reduces-total-perimeter-allowed">Example A — removing an edge PU reduces total perimeter
(allowed)<a class="anchor" aria-label="anchor" href="#example-a-removing-an-edge-pu-reduces-total-perimeter-allowed"></a>
</h3>
<p>Here the patch has two selected PUs in a line. <code>U</code> is an
<strong>edge unit</strong> because it touches <code>.</code> above,
below, and right.</p>
<p><strong>Before removing U</strong></p>
<pre class="text"><code>| . | . |
| S | U |
| . | . |</code></pre>
<p>Compute the <strong>total perimeter</strong>:</p>
<ul>
<li>Two adjacent cells have perimeter =6 km<br>
(Each cell has 4 edges → 8 total, minus 2 for the shared edge → 6)</li>
</ul>
<p>So:</p>
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mtext mathvariant="normal">before</mtext></mrow><annotation encoding="application/x-tex">P{\text{before}}</annotation></semantics></math>=
6 km</li>
</ul>
<p><strong>After removing U</strong></p>
<pre class="text"><code>| . | . |
| S | . |
| . | . |</code></pre>
<ul>
<li>Single cell has perimeter = 4 km</li>
</ul>
<p>So:</p>
<ul>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mtext mathvariant="normal">after</mtext></mrow><annotation encoding="application/x-tex">P{\text{after}}</annotation></semantics></math>
= 4 km</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mtext mathvariant="normal">perimeter</mtext></mrow><annotation encoding="application/x-tex">\Delta \text{perimeter}</annotation></semantics></math>
= 4 - 6 =−2 km</p></li>
</ul>
<p>Now apply the Stage 3 boundary check:</p>
<p>Assume:</p>
<ul>
<li><p><code>boundary_penalty = 10</code></p></li>
<li><p><code>unit_cost = 5</code></p></li>
</ul>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mtext mathvariant="normal">Objective</mtext><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mtext mathvariant="normal">boundary_penalty</mtext><mo>×</mo><mi mathvariant="normal">Δ</mi><mtext mathvariant="normal">perimeter</mtext><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mtext mathvariant="normal">unit_cost</mtext><mspace width="0.222em"></mspace><mtext mathvariant="normal">= 10</mtext><mspace width="0.222em"></mspace><mo>×</mo><mspace width="0.222em"></mspace><mo stretchy="false" form="prefix">(</mo><mi>−</mi><mn>2</mn><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mn>5</mn><mo>=</mo><mi>−</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\Delta \text{Objective} = (\text{boundary_penalty} \times \Delta \text{perimeter}) - \text{unit_cost}\ \text{= 10}\ \times \ (-2) - 5 = -2  </annotation></semantics></math></p>
<p>Decision:</p>
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mtext mathvariant="normal">Objective</mtext><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\Delta \text{Objective} \le 0</annotation></semantics></math>
→ objective decreased → <strong>allow removal</strong> (if other
constraints pass).</li>
</ul>
<hr>
</div>
<div class="section level3">
<h3 id="example-b-removing-an-edge-pu-increases-total-perimeter-blocked-but-patch-stays-connected">Example B — removing an edge PU increases total perimeter (blocked),
but patch stays connected<a class="anchor" aria-label="anchor" href="#example-b-removing-an-edge-pu-increases-total-perimeter-blocked-but-patch-stays-connected"></a>
</h3>
<p>Here we use a 3×2 rectangle. Let <code>U</code> be the <strong>middle
PU on the bottom row</strong>.<br><code>U</code> is an <strong>edge unit</strong> because it touches
<code>.</code> below (outside the rectangle).</p>
<p><strong>Before removing U</strong></p>
<pre class="text"><code>| S | S | S |
| S | U | S |</code></pre>
<p>Compute the <strong>total perimeter</strong>:</p>
<p>A 3×2 rectangle has perimeter:</p>
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mtext mathvariant="normal">before</mtext></mrow><annotation encoding="application/x-tex">P{\text{before}}</annotation></semantics></math>=
2(3+2)=10 km</li>
</ul>
<p><strong>After removing U</strong></p>
<pre class="text"><code>| S | S | S |
| S | . | S |</code></pre>
<p>Important: the patch is <strong>still connected</strong> (you can
still walk between all remaining <code>S</code> cells via shared borders
on the top row).</p>
<p>Now compute the <strong>total perimeter after</strong>.</p>
<p>We can use the neighbour rule:</p>
<ul>
<li><p><code>U</code> had
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">k=3</annotation></semantics></math>
selected neighbours (left, right, and above are selected; below is
not).</p></li>
<li><p>Therefore:</p></li>
</ul>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mtext mathvariant="normal">perimeter</mtext><mo>=</mo><mi>−</mi><mn>4</mn><mo>+</mo><mn>2</mn><mi>k</mi><mo>=</mo><mi>−</mi><mn>4</mn><mo>+</mo><mn>2</mn><mo stretchy="false" form="prefix">(</mo><mn>3</mn><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>+</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">
\Delta \text{perimeter} = -4 + 2k = -4 + 2(3) = +2
</annotation></semantics></math></p>
<p>So:</p>
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mtext mathvariant="normal">after</mtext></msub><mo>=</mo><mn>10</mn><mo>+</mo><mn>2</mn><mo>=</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">P_{\text{after}} = 10 + 2 = 12</annotation></semantics></math>
km<br>
</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mtext mathvariant="normal">perimeter</mtext><mo>=</mo><mi>+</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\Delta \text{perimeter} = +2</annotation></semantics></math>
km</li>
</ul>
<p>Now apply the boundary check:</p>
<p>Assume:</p>
<ul>
<li><p><code>boundary_penalty = 10</code></p></li>
<li><p><code>unit_cost = 5</code></p></li>
</ul>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mtext mathvariant="normal">Objective</mtext><mo>=</mo><mn>10</mn><mo>×</mo><mo stretchy="false" form="prefix">(</mo><mi>+</mi><mn>2</mn><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mn>5</mn><mo>=</mo><mi>+</mi><mn>15</mn></mrow><annotation encoding="application/x-tex">\Delta \text{Objective} = 10 \times (+2) - 5 = +15
</annotation></semantics></math></p>
<p>Decision:</p>
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mtext mathvariant="normal">Objective</mtext><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\Delta \text{Objective} &gt; 0</annotation></semantics></math>
→ objective increased → <strong>block removal</strong>
</li>
</ul>
<p><strong>Interpretation:</strong><br>
Removing <code>U</code> saves cost, but it <em>exposes new edge</em> on
its three neighbours, increasing total perimeter enough that the
boundary-penalised objective gets worse.</p>
</div>
</div>
<div class="section level2">
<h2 id="practical-guidance-for-choosing-boundary_penalty">Practical guidance for choosing <code>boundary_penalty</code><a class="anchor" aria-label="anchor" href="#practical-guidance-for-choosing-boundary_penalty"></a>
</h2>
<p>There isn’t one universal “correct” value because it depends on the
scale and units of your costs and boundary lengths. A practical
workflow:</p>
<ol style="list-style-type: decimal">
<li><p><strong>Start with
<code>boundary_penalty = 0</code></strong><br>
This turns off boundary blocking. Whittling then only uses targets +
patch-size + split viability rules.</p></li>
<li><p><strong>Increase gradually</strong> and observe how solutions
change<br>
As you increase it, removals that create extra edge become more likely
to be blocked, producing smoother patches.</p></li>
<li><p><strong>Do a small sensitivity check</strong><br>
Try a few values spanning a small range (e.g., 0, low, medium, high) and
compare: ```</p></li>
</ol>
<ul>
<li><p>number of patches</p></li>
<li><p>mean/median patch size</p></li>
<li><p>total perimeter</p></li>
<li><p>total planning-unit cost retained/removed ```</p></li>
</ul>
<p>If <code>boundary_penalty</code> is too high, Stage 3 can become
conservative: it may keep “bridges” or edge units because removing them
would raise the boundary term too much.</p>
</div>
<div class="section level2">
<h2 id="faq">FAQ<a class="anchor" aria-label="anchor" href="#faq"></a>
</h2>
<p><strong>Does Stage 3 re-run the optimiser
(prioritizr)?</strong><br>
No. Stage 3 does local, one-unit-at-a-time removal tests. It never
resolves a new optimisation problem.</p>
<p><strong>Are we comparing costs to the Stage 2
solution?</strong><br>
Not directly. Stage 3 compares the objective <strong>before vs after
removing one candidate unit</strong>. It uses
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>o</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Δ objective</annotation></semantics></math>
(local change), not a full re-optimisation.</p>
<p><strong>Is it “per patch” or “whole solution”?</strong><br>
Conceptually the objective is for the whole solution (sum of PU costs +
boundary penalty term). In code, the change is computed locally using
the candidate’s neighbour relationships, because only local boundary
edges change when you remove one unit.</p>
<p><strong>What if my costs are not area?</strong><br>
That’s fine—<code>boundary_penalty</code> still converts perimeter into
the same units as your chosen cost layer. The interpretation becomes:
“how much cost am I willing to pay to avoid 1 km of extra edge?”</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Jason D. Everett, Anthony J. Richardson, Robert J. Smith.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.2.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
