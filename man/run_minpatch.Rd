% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/minpatch.R
\name{run_minpatch}
\alias{run_minpatch}
\title{Run MinPatch algorithm on prioritizr solution}
\usage{
run_minpatch(
  prioritizr_problem,
  prioritizr_solution,
  min_patch_size,
  patch_radius,
  boundary_penalty = 0,
  remove_small_patches = TRUE,
  add_patches = TRUE,
  whittle_patches = TRUE,
  solution_column = "solution_1",
  verbose = TRUE
)
}
\arguments{
\item{prioritizr_problem}{A prioritizr problem object}

\item{prioritizr_solution}{A solved prioritizr solution object}

\item{min_patch_size}{Minimum patch size threshold}

\item{patch_radius}{Radius for adding new patches}

\item{boundary_penalty}{Boundary penalty value (default = 0)}

\item{remove_small_patches}{Logical, whether to remove small patches (Stage 1, default = TRUE)}

\item{add_patches}{Logical, whether to add new patches to meet targets (Stage 2, default = TRUE)}

\item{whittle_patches}{Logical, whether to remove unnecessary units (Stage 3, default = TRUE)}

\item{solution_column}{Name of solution column (default = "solution_1")}

\item{verbose}{Logical, whether to print progress (default = TRUE)}
}
\value{
MinPatch result object with enhanced reporting using prioritizr functions
}
\description{
This is the main function that applies the MinPatch algorithm to a prioritizr
solution to ensure all protected areas meet minimum size thresholds.
The function uses prioritizr summary functions where possible to reduce code
duplication and ensure consistency with prioritizr calculations.
}
\details{
The MinPatch algorithm consists of three stages:
\enumerate{
  \item Remove small patches: Removes patches smaller than min_patch_size
  \item Add new patches: Adds patches to meet conservation targets
  \item Whittle patches: Removes unnecessary planning units
}

**Important**: If you set \code{remove_small_patches = TRUE} but
\code{add_patches = FALSE}, the algorithm may remove patches without
compensating, potentially violating conservation targets. In such cases,
a warning will be issued. Consider using \code{add_patches = TRUE} or
a smaller \code{min_patch_size} to maintain target achievement.
}
\examples{

library(prioritizr)
library(sf)
library(terra)

# Get example data from prioritizr
dat <- c(get_sim_pu_raster(), get_sim_features()) \%>\%
  as.polygons(dissolve = FALSE, values = TRUE) \%>\%
  sf::st_as_sf() \%>\%
  dplyr::rename(cost = layer)

st_crs(dat) <- NA

features = colnames(dat) \%>\%
  stringr::str_subset("feature_")

# Create prioritizr problem
p <- problem(dat, features, cost_column = "cost") \%>\%
  add_min_set_objective() \%>\%
  add_relative_targets(0.17) \%>\%  # 17\% of each feature
  add_binary_decisions() \%>\%
  add_default_solver(verbose = FALSE)

# Solve problem
s <- solve(p)

# Apply MinPatch with all stages
result <- run_minpatch(
  prioritizr_problem = p,
  prioritizr_solution = s,
  min_patch_size = 0.05,
  patch_radius = 0.3,
)

# Apply MinPatch with only Stage 1 and 3 (skip adding patches)
result2 <- run_minpatch(
  prioritizr_problem = p,
  prioritizr_solution = s,
  min_patch_size = 0.05,
  patch_radius = 0.3,
  add_patches = FALSE
)

print_minpatch_summary(result)

}
