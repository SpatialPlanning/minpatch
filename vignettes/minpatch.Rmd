---
title: "MinPatch with prioritizr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{MinPatch with prioritizr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 8,
  fig.height = 6,
  eval = TRUE  # Set to TRUE when running interactively
)
```

# Introduction

This vignette demonstrates how to use MinPatch with real conservation planning data from prioritizr. We'll use the simulated dataset included with prioritizr to show a complete workflow from problem formulation through MinPatch post-processing.

```{r setup, message=FALSE}
library(minpatch)
library(prioritizr)
library(sf)
library(terra)
library(dplyr)
library(ggplot2)
library(patchwork)
```

## Step 1: Load and Examine the Data

```{r load-data}
dat <- c(get_sim_pu_raster(), get_sim_features()) %>% 
  as.polygons(dissolve = FALSE, values = TRUE) %>%
  sf::st_as_sf() %>% 
  dplyr::rename(cost = layer)

st_crs(dat) <- NA

features = colnames(dat) %>% 
  stringr::str_subset("feature_")

```

## Step 2: Create and Solve a prioritizr Problem

We'll create a simple minimum set problem with 17% targets for all features:

```{r prioritizr-problem}
# Create prioritizr problem
p <- problem(dat, features, cost_column = "cost") %>%
  add_min_set_objective() %>%
  add_relative_targets(0.17) %>%  # 17% of each feature
  add_binary_decisions() %>%
  add_default_solver(verbose = FALSE)

# Solve the problem
s <- solve(p)
```

```{r}
# plot map of prioritization
plot_prioritizr(s)

```

## Step 3: Run MinPatch

Now we can apply MinPatch directly to the prioritizr objects. The `run_minpatch()` function automatically extracts all necessary data from the prioritizr solution object:

```{r minpatch-parameters}
# Calculate reasonable parameters based on planning unit characteristics
median_area <- median(st_area(dat))

# Set minimum patch size to 5x median planning unit area
min_patch_size <- median_area * 5

# Set patch radius to encompass approximately 10 planning units
patch_radius <- sqrt(median_area * 10)

cat("MinPatch parameters:\n")
cat("- Minimum patch size:", round(min_patch_size, 3), "square meters\n")
cat("- Patch radius:", round(patch_radius,3), "meters\n")
cat("- This means patches must be at least", round(min_patch_size/median_area, 3),
    "times the median planning unit size\n")
```

Run MinPatch with automatic data extraction from prioritizr objects

```{r run-minpatch}
result <- run_minpatch(
  prioritizr_problem = p,
  prioritizr_solution = s,
  min_patch_size = min_patch_size,
  patch_radius = patch_radius,
  boundary_penalty = 0.001,  # Small boundary penalty for connectivity
  remove_small_patches = TRUE,
  add_patches = TRUE,
  whittle_patches = TRUE,
  verbose = TRUE
)

```

## Step 4: Analyze the Results

Let's examine what MinPatch accomplished:

```{r analyze-results}
# Print comprehensive summary
print_minpatch_summary(result)

# Compare original vs MinPatch solutions
comparison <- compare_solutions(result)

# Print overall comparison
cat("=== Overall Solution Comparison ===\n")
print(comparison$overall)

# Print feature-level comparison
cat("\n=== Feature-Level Area Comparison ===\n")
print(comparison$features)

# Print summary statistics
cat("\n=== Feature Change Summary ===\n")
print(comparison$summary)

# cat("Features with increased area:", comparison$summary$features_improved, "\n")
# cat("Features with decreased area:", comparison$summary$features_reduced, "\n")
# cat("Features with unchanged area:", comparison$summary$features_unchanged, "\n")
# cat("Targets gained:", comparison$summary$targets_gained, "\n")
# cat("Targets lost:", comparison$summary$targets_lost, "\n")
```

### Feature Representation Analysis

```{r feature-analysis}
# Create solution data for prioritizr analysis
minpatch_solution_data <- result$solution[c("minpatch")]

# Use prioritizr functions for accurate feature representation analysis
feature_rep <- prioritizr::eval_feature_representation_summary(p, minpatch_solution_data)
target_coverage <- prioritizr::eval_target_coverage_summary(p, minpatch_solution_data)

# Summary statistics
targets_met <- sum(target_coverage$met)
mean_achievement <- mean(feature_rep$relative_held, na.rm = TRUE)

cat("Conservation Performance:\n")
cat("- Targets met:", targets_met, "out of", nrow(feature_rep), "features\n")
cat("- Mean target achievement:", round(mean_achievement * 100, 1), "%\n")

# Show features with lowest achievement
combined_results <- data.frame(
  feature_id = seq_len(nrow(feature_rep)),
  proportion_met = feature_rep$relative_held,
  target_met = target_coverage$met
)

worst_features <- combined_results[order(combined_results$proportion_met), ][1:5, ]

cat("\nFeatures with lowest target achievement:\n")
print(worst_features)
```

### Spatial Configuration Improvements

```{r spatial-analysis}
initial_stats <- result$patch_stats$initial
final_stats <- result$patch_stats$final

cat("Spatial Configuration Changes:\n")
cat("- Initial patches:", initial_stats$all_patch_count, 
    "(", initial_stats$valid_patch_count, "valid)\n")
cat("- Final patches:", final_stats$all_patch_count, 
    "(", final_stats$valid_patch_count, "valid)\n")
cat("- Patch consolidation:", 
    round((1 - final_stats$all_patch_count/initial_stats$all_patch_count) * 100, 1), 
    "% reduction\n")
cat("- Median patch size increase:", 
    round(final_stats$median_all_patch / initial_stats$median_all_patch, 1), "x\n")
```

## Step 5: Visualize the Results

Let's create maps to visualize the changes MinPatch made:

```{r visualization}
plot_minpatch(result, title = "MinPatch Results")
```

## Working with Locked Constraints

MinPatch automatically respects locked-in and locked-out constraints from prioritizr. This is useful when certain areas must be included (e.g., existing reserves) or excluded (e.g., areas with conflicting uses).

### Example: Adding Locked-In Constraints

Let's designate some existing planning units as locked-in (must be conserved):

```{r locked-in-example}
# Select some units as existing protected areas (locked-in)
locked_in_units <- c(10, 11, 20, 21, 30, 31)

# Create problem with locked-in constraints
p_locked_in <- problem(dat, features, cost_column = "cost") %>%
  add_min_set_objective() %>%
  add_relative_targets(0.17) %>%
  add_locked_in_constraints(locked_in_units) %>%
  add_binary_decisions() %>%
  add_default_solver(verbose = FALSE)

# Solve and apply MinPatch
s_locked_in <- solve(p_locked_in)

result_locked_in <- run_minpatch(
  prioritizr_problem = p_locked_in,
  prioritizr_solution = s_locked_in,
  min_patch_size = min_patch_size,
  patch_radius = patch_radius,
  boundary_penalty = 0.001,
  verbose = FALSE
)

# Verify locked-in units are preserved
cat("Locked-in units in final solution:\n")
cat("Units:", locked_in_units, "\n")
cat("Status in solution:", result_locked_in$solution$minpatch[locked_in_units], "\n")
cat("All locked-in units preserved:",
    all(result_locked_in$solution$minpatch[locked_in_units] == 1), "\n")
```

### Example: Adding Locked-Out Constraints

Now let's exclude certain areas from selection (e.g., areas with conflicting land uses):

```{r locked-out-example}
# Select some units to exclude (locked-out)
locked_out_units <- c(50, 51, 60, 61, 70, 71)

# Create problem with locked-out constraints
p_locked_out <- problem(dat, features, cost_column = "cost") %>%
  add_min_set_objective() %>%
  add_relative_targets(0.17) %>%
  add_locked_out_constraints(locked_out_units) %>%
  add_binary_decisions() %>%
  add_default_solver(verbose = FALSE)

# Solve and apply MinPatch
s_locked_out <- solve(p_locked_out)

result_locked_out <- run_minpatch(
  prioritizr_problem = p_locked_out,
  prioritizr_solution = s_locked_out,
  min_patch_size = min_patch_size,
  patch_radius = patch_radius,
  boundary_penalty = 0.001,
  verbose = FALSE
)

# Verify locked-out units are excluded
cat("Locked-out units in final solution:\n")
cat("Units:", locked_out_units, "\n")
cat("Status in solution:", result_locked_out$solution$minpatch[locked_out_units], "\n")
cat("All locked-out units excluded:",
    all(result_locked_out$solution$minpatch[locked_out_units] == 0), "\n")
```

### Example: Combining Both Constraint Types

You can use both locked-in and locked-out constraints together:

```{r locked-combined-example}
# Create problem with both constraint types
p_locked_both <- problem(dat, features, cost_column = "cost") %>%
  add_min_set_objective() %>%
  add_relative_targets(0.17) %>%
  add_locked_in_constraints(locked_in_units) %>%
  add_locked_out_constraints(locked_out_units) %>%
  add_binary_decisions() %>%
  add_default_solver(verbose = FALSE)

# Solve and apply MinPatch
s_locked_both <- solve(p_locked_both)

result_locked_both <- run_minpatch(
  prioritizr_problem = p_locked_both,
  prioritizr_solution = s_locked_both,
  min_patch_size = min_patch_size,
  patch_radius = patch_radius,
  boundary_penalty = 0.001,
  verbose = FALSE
)

cat("Constraint Summary:\n")
cat("- Locked-in units preserved:",
    all(result_locked_both$solution$minpatch[locked_in_units] == 1), "\n")
cat("- Locked-out units excluded:",
    all(result_locked_both$solution$minpatch[locked_out_units] == 0), "\n")
```

### Key Points About Locked Constraints

1. **Locked-in units are never removed**: Even if they form patches smaller than `min_patch_size`, locked-in units will be preserved in all three stages of MinPatch.

2. **Locked-out units are never selected**: During Stage 2 (patch addition), locked-out units will not be considered even if they would help meet conservation targets.

3. **Automatic detection**: MinPatch automatically extracts and applies locked constraints from your prioritizr problemâ€”no additional parameters needed!

4. **Warnings for small locked-in patches**: If locked-in units form patches smaller than `min_patch_size`, MinPatch will issue a warning but still preserve those units.

## Understanding the Results

### Lets check the process

```{r}
# First remove small patches
result_remove <- run_minpatch(
  prioritizr_problem = p,
  prioritizr_solution = s,
  min_patch_size = min_patch_size,
  patch_radius = patch_radius,
  remove_small_patches = TRUE,
  add_patches = FALSE,
  whittle_patches = FALSE,
  verbose = FALSE
)

# Next add to ensure patches meet minimum size
result_add <- run_minpatch(
  prioritizr_problem = p,
  prioritizr_solution = s,
  min_patch_size = min_patch_size,
  patch_radius = patch_radius,
  remove_small_patches = TRUE,
  add_patches = TRUE,
  whittle_patches = FALSE,
  verbose = FALSE
)

# Finally, try and remove areas without degrading the solution
result_whittle <- run_minpatch(
  prioritizr_problem = p,
  prioritizr_solution = s,
  min_patch_size = min_patch_size,
  patch_radius = patch_radius,
  remove_small_patches = TRUE,
  add_patches = TRUE,
  whittle_patches = TRUE,
  verbose = FALSE
)

```

Plot the comparison

```{r}
patchwork::wrap_plots(
  plot_minpatch(result_remove, title = "Remove Small Patches"),
  plot_minpatch(result_add, title = "Add Patches"),
  plot_minpatch(result_whittle, title = "Whittle Planning Units"), 
  guides = "collect",
  ncol = 3
) & theme(legend.position = "bottom")


```

### What MinPatch Accomplished

1. **Patch Consolidation**: MinPatch reduced the number of patches by removing small, inefficient patches and consolidating the remaining areas into larger, more viable patches.

2. **Size Constraint Satisfaction**: All final patches now meet the minimum size threshold, ensuring they are large enough to be ecologically viable and cost-effective to manage.

3. **Target Achievement**: Conservation targets are maintained or improved, demonstrating that MinPatch doesn't compromise conservation effectiveness.

4. **Cost Optimization**: The boundary penalty helps create more compact patches, potentially reducing management costs.

### Key Insights

- **Efficiency vs. Viability Trade-off**: The original prioritizr solution was mathematically optimal but contained many small patches. MinPatch trades some mathematical optimality for practical viability.

- **Context-Dependent Parameters**: The choice of minimum patch size and patch radius should be based on ecological requirements, management constraints, and expert knowledge.

- **Computational Considerations**: Processing time scales with the number of planning units and the complexity of the spatial configuration.

## Best Practices

### Parameter Selection

1. **Minimum Patch Size**: Base this on:
   - Ecological requirements (home range sizes, minimum viable populations)
   - Management efficiency (minimum economically viable management units)
   - Expert knowledge of the study system

2. **Patch Radius**: Should be:
   - Large enough to allow for elongated patches
   - Not so large as to create unnecessarily large patches
   - Based on typical dispersal distances or management scales

3. **Boundary Penalty**: Use when:
   - Connectivity between patches is important
   - Compact patches are preferred for management
   - Edge effects are a concern

### Validation

Always validate your results by:

1. **Checking target achievement**: Ensure conservation goals are still met
2. **Examining spatial patterns**: Verify that patches make ecological sense
3. **Comparing costs**: Understand the trade-offs involved
4. **Expert review**: Have domain experts review the final configuration

## Advanced Usage

### Multiple Scenarios

You can run MinPatch with different parameters to explore trade-offs:

```{r multiple-scenarios, eval=TRUE}
# Conservative scenario (larger patches)
result_conservative <- run_minpatch(
  prioritizr_problem = p,
  prioritizr_solution = s,
  min_patch_size = median_area * 10,  # Larger minimum size
  patch_radius = patch_radius * 1.5,
  boundary_penalty = 0.01,  # Higher boundary penalty
  verbose = FALSE
)

# Compare scenarios
compare_solutions(result_conservative)
```

## Conclusion

MinPatch provides a powerful way to post-process prioritizr solutions to ensure they meet minimum patch size requirements while maintaining conservation effectiveness. The Tasmania case study demonstrates that MinPatch can successfully:

- Handle real-world conservation planning datasets
- Consolidate fragmented solutions into viable patch configurations
- Maintain or improve conservation target achievement
- Provide transparent reporting of trade-offs and improvements

By integrating MinPatch into your conservation planning workflow, you can bridge the gap between mathematically optimal solutions and practically implementable conservation strategies.

## Session Information

```{r session-info}
sessionInfo()
```
