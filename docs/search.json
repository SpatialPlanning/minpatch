[{"path":"/articles/boundary-penalty.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Boundary penalty in MinPatch","text":"boundary_penalty optional parameter discourages irregular (high-perimeter) patch shapes Stage 3 (Simulated Whittling). key idea boundary_penalty converts boundary length (perimeter) “currency” planning-unit cost, MinPatch can trade saving cost creating edge. practice: higher boundary_penalty → stronger preference smooth, compact patches (less edge) lower boundary_penalty → willingness accept jagged edges reduce planning-unit cos","code":""},{"path":"/articles/boundary-penalty.html","id":"where-it-is-used-in-minpatch","dir":"Articles","previous_headings":"","what":"Where it is used in MinPatch","title":"Boundary penalty in MinPatch","text":"MinPatch re-run optimiser Stage 3. Instead, tests removing one edge planning unit time accepts removal : Targets remain met Minimum patch-size requirements remain met (including splits) boundary-penalised objective increase (boundary_penalty > 0) means Stage 3 uses local “delta” test (change objective) rather solving new optimisation problem.","code":""},{"path":"/articles/boundary-penalty.html","id":"decision-rule-the-thing-to-remember","dir":"Articles","previous_headings":"","what":"Decision rule (the thing to remember)","title":"Boundary penalty in MinPatch","text":"Conceptually, Stage 3 evaluates objective form: Objective=∑(PU cost)+boundary_penalty×(total perimeter) \\text{Objective} = \\sum(\\text{PU cost}) + \\text{boundary_penalty} \\times (\\text{total perimeter}) testing removal single planning unit, code computes local change: ΔObjective=(boundary_penalty×Δperimeter)−unit_cost \\Delta \\text{Objective} = (\\text{boundary_penalty} \\times \\Delta \\text{perimeter}) - \\text{unit_cost} - ΔObjective>0\\Delta \\text{Objective} > 0 → objective increased → block removal - ΔObjective≤0\\Delta \\text{Objective} \\le 0 → objective stayed decreased → allow removal (assuming constraints pass)","code":""},{"path":"/articles/boundary-penalty.html","id":"why-this-looks-like-total_cost_change-in-the-code","dir":"Articles","previous_headings":"Decision rule (the thing to remember)","what":"Why this looks like “total_cost_change” in the code","title":"Boundary penalty in MinPatch","text":"code, ’ll often see value like: total_cost_change = boundary_cost_change - unit_cost exactly ΔObjective\\Delta \\text{Objective} written code form: boundary_cost_change corresponds boundary_penalty × Δperimeter unit_cost cost save removing unit : total_cost_change change objective.","code":""},{"path":"/articles/boundary-penalty.html","id":"what-does-same-currency-as-cost-mean","dir":"Articles","previous_headings":"","what":"What does “same currency as cost” mean?","title":"Boundary penalty in MinPatch","text":"objective combines two different things: Planning-unit cost (whatever choose: dollars, area, opportunity cost, etc.) Perimeter (boundary length: km, m, “edge count” depending data) add together, boundary_penalty acts like conversion rate: converts boundary length “cost units”. Objective=∑(PU cost)+boundary_penalty×(total perimeter)\\text{Objective} = \\sum(\\text{PU cost}) + \\text{boundary_penalty} \\times (\\text{total perimeter})","code":""},{"path":"/articles/boundary-penalty.html","id":"if-your-pu-cost-is-in-dollars","dir":"Articles","previous_headings":"What does “same currency as cost” mean?","what":"If your PU cost is in dollars","title":"Boundary penalty in MinPatch","text":"PU cost might : $/PU\\$ / \\text{PU} $/km2\\$ / \\text{km}^2 perimeter km boundary_penalty behaves like dollars per km edge: $/km\\$ / \\text{km} Interpretation:boundary_penalty price willing pay avoid 1 km extra boundary. Example: boundary_penalty = 2000, adding 1 km perimeter “costs” $2000 objective.","code":""},{"path":"/articles/boundary-penalty.html","id":"if-your-pu-cost-is-area","dir":"Articles","previous_headings":"What does “same currency as cost” mean?","what":"If your PU cost is area","title":"Boundary penalty in MinPatch","text":"Sometimes “cost” literally area (e.g., PU cost = area km²). : PU cost km² perimeter km boundary_penalty behaves like km² per km can think “equivalent area cost per km edge”. Interpretation:boundary_penalty tells much extra area cost willing accept avoid 1 km extra boundary. boundary_penalty = 0.5, extra 1 km edge treated like adding 0.5 km² cost.","code":""},{"path":"/articles/boundary-penalty.html","id":"the-simplest-way-to-remember-it","dir":"Articles","previous_headings":"What does “same currency as cost” mean?","what":"The simplest way to remember it","title":"Boundary penalty in MinPatch","text":"unit_cost = savings get removing PU boundary_penalty × Δperimeter = “edge bill” pay (save) boundary changes Stage 3 removes PU : ΔObjective=(boundary_penalty×Δperimeter)−unit_cost≤0 \\Delta \\text{Objective} = (\\text{boundary_penalty} \\times \\Delta \\text{perimeter}) - \\text{unit_cost} \\le 0 can read : remove PU edge bill doesn’t outweigh cost saved.","code":""},{"path":"/articles/boundary-penalty.html","id":"worked-examples-with-explicit-total-perimeter","dir":"Articles","previous_headings":"","what":"Worked examples (with explicit total perimeter)","title":"Boundary penalty in MinPatch","text":"Assumptions examples: 4-neighbour adjacency (//left/right) shared cell edge length 1 km total perimeter perimeter whole selected patch (km) useful identity (grid perimeter change): removed PU kkselected neighbours (0–4), removing changes perimeter : Δperimeter=−4+2k \\Delta \\text{perimeter} = -4 + 2k perimeter increases k≥3k \\ge 3 (.e., PU “shielding” three selected neighbours).","code":""},{"path":"/articles/boundary-penalty.html","id":"example-a-removing-an-edge-pu-reduces-total-perimeter-allowed","dir":"Articles","previous_headings":"Worked examples (with explicit total perimeter)","what":"Example A — removing an edge PU reduces total perimeter (allowed)","title":"Boundary penalty in MinPatch","text":"patch two selected PUs line. U edge unit touches . , , right. removing U Compute total perimeter: Two adjacent cells perimeter =6 km (cell 4 edges → 8 total, minus 2 shared edge → 6) : PbeforeP{\\text{}}= 6 km removing U Single cell perimeter = 4 km : PafterP{\\text{}} = 4 km Δperimeter\\Delta \\text{perimeter} = 4 - 6 =−2 km Now apply Stage 3 boundary check: Assume: boundary_penalty = 10 unit_cost = 5 ΔObjective=(boundary_penalty×Δperimeter)−unit_cost= 10×(−2)−5=−2\\Delta \\text{Objective} = (\\text{boundary_penalty} \\times \\Delta \\text{perimeter}) - \\text{unit_cost}\\ \\text{= 10}\\ \\times \\ (-2) - 5 = -2 Decision: ΔObjective≤0\\Delta \\text{Objective} \\le 0 → objective decreased → allow removal (constraints pass).","code":"| . | . | | S | U | | . | . | | . | . | | S | . | | . | . |"},{"path":"/articles/boundary-penalty.html","id":"example-b-removing-an-edge-pu-increases-total-perimeter-blocked-but-patch-stays-connected","dir":"Articles","previous_headings":"Worked examples (with explicit total perimeter)","what":"Example B — removing an edge PU increases total perimeter (blocked), but patch stays connected","title":"Boundary penalty in MinPatch","text":"use 3×2 rectangle. Let U middle PU bottom row.U edge unit touches . (outside rectangle). removing U Compute total perimeter: 3×2 rectangle perimeter: PbeforeP{\\text{}}= 2(3+2)=10 km removing U Important: patch still connected (can still walk remaining S cells via shared borders top row). Now compute total perimeter . can use neighbour rule: U k=3k=3 selected neighbours (left, right, selected; ). Therefore: Δperimeter=−4+2k=−4+2(3)=+2 \\Delta \\text{perimeter} = -4 + 2k = -4 + 2(3) = +2 : Pafter=10+2=12P_{\\text{}} = 10 + 2 = 12 km Δperimeter=+2\\Delta \\text{perimeter} = +2 km Now apply boundary check: Assume: boundary_penalty = 10 unit_cost = 5 ΔObjective=10×(+2)−5=+15\\Delta \\text{Objective} = 10 \\times (+2) - 5 = +15 Decision: ΔObjective>0\\Delta \\text{Objective} > 0 → objective increased → block removal Interpretation: Removing U saves cost, exposes new edge three neighbours, increasing total perimeter enough boundary-penalised objective gets worse.","code":"| S | S | S | | S | U | S | | S | S | S | | S | . | S |"},{"path":"/articles/boundary-penalty.html","id":"practical-guidance-for-choosing-boundary_penalty","dir":"Articles","previous_headings":"","what":"Practical guidance for choosing boundary_penalty","title":"Boundary penalty in MinPatch","text":"isn’t one universal “correct” value depends scale units costs boundary lengths. practical workflow: Start boundary_penalty = 0 turns boundary blocking. Whittling uses targets + patch-size + split viability rules. Increase gradually observe solutions change increase , removals create extra edge become likely blocked, producing smoother patches. small sensitivity check Try values spanning small range (e.g., 0, low, medium, high) compare: ``` number patches mean/median patch size total perimeter total planning-unit cost retained/removed ``` boundary_penalty high, Stage 3 can become conservative: may keep “bridges” edge units removing raise boundary term much.","code":""},{"path":"/articles/boundary-penalty.html","id":"faq","dir":"Articles","previous_headings":"","what":"FAQ","title":"Boundary penalty in MinPatch","text":"Stage 3 re-run optimiser (prioritizr)? . Stage 3 local, one-unit---time removal tests. never resolves new optimisation problem. comparing costs Stage 2 solution? directly. Stage 3 compares objective vs removing one candidate unit. uses ΔobjectiveΔ objective (local change), full re-optimisation. “per patch” “whole solution”? Conceptually objective whole solution (sum PU costs + boundary penalty term). code, change computed locally using candidate’s neighbour relationships, local boundary edges change remove one unit. costs area? ’s fine—boundary_penalty still converts perimeter units chosen cost layer. interpretation becomes: “much cost willing pay avoid 1 km extra edge?”","code":""},{"path":"/articles/minpatch-oceandatr-Seychelles.html","id":"introduction","dir":"Articles","previous_headings":"","what":"1. Introduction","title":"Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)","text":"many marine spatial planning problems, goal meet representation targets lowest possible cost, also consider selected areas arranged space. Highly fragmented marine protected areas can difficult manage enforce, small isolated patches may sustain viable populations. Scattered solutions can also difficult justify decision-makers stakeholders. Two R packages especially helpful tackling issues marine context. oceandatr package offers practical way build realistic, analysis-ready marine planning datasets. helps users obtain planning boundaries (e.g., exclusive economic zones high-seas regions), generate planning-unit grids, access global ocean datasets—including bathymetry, geomorphology, seamounts, environmental conditions—aligned grids. Together, tools make easier assemble consistent inputs marine spatial planning analyses. minpatch package post-processing tool modifies conservation planning solutions produced prioritizr reduce fragmentation. enforces user-defined minimum patch size removing patches small adding new areas maintain conservation targets. simplifies solution removing unnecessary planning units, tracking changes affect patch structure total cost. vignette, demonstrate use oceandatr minpatch using simple marine example Seychelles Exclusive Economic Zone. first use oceandatr construct gridded planning problem set marine features solve standard prioritizr minimum-set problem. apply minpatch explore different minimum patch sizes boundary penalties influence resulting solutions.","code":""},{"path":[]},{"path":"/articles/minpatch-oceandatr-Seychelles.html","id":"load-packages","dir":"Articles","previous_headings":"2. Study region and planning units with oceandatr","what":"2.1 Load packages","title":"Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)","text":"","code":"library(oceandatr) library(terra) library(sf) library(dplyr) library(ggplot2) library(patchwork) library(prioritizr) library(minpatch) library(purrr) library(tibble) library(kableExtra) set.seed(123) # Note: oceandatr requires an up-to-date version of curl for data downloads # install.packages(\"curl\")  # packageVersion(\"curl\")"},{"path":"/articles/minpatch-oceandatr-Seychelles.html","id":"seychelles-eez-as-the-planning-region","dir":"Articles","previous_headings":"2. Study region and planning units with oceandatr","what":"2.2 Seychelles EEZ as the planning region","title":"Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)","text":"start using get_boundary() oceandatr obtain Seychelles Exclusive Economic zone (EEZ). defines marine planning domain.","code":"Seychelles_eez <- get_boundary(name = \"Seychelles\")  # plot to check we have Seychelles' EEZ plot(Seychelles_eez[1],       col = \"lightgreen\",       main = \"Seychelles EEZ\",       axes = TRUE)"},{"path":"/articles/minpatch-oceandatr-Seychelles.html","id":"choose-an-equal-area-projection","dir":"Articles","previous_headings":"2. Study region and planning units with oceandatr","what":"2.3 Choose an equal-area projection","title":"Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)","text":"reproject planning region equal-area projection ensure area- distance-based calculations meaningful.","code":"# use sf::st_bbox to get the bounding box coordinates (in lon/lat) #sf::st_bbox(Seychelles_eez)  # use projectionwizard.org to choose an equal-area projection, then store as a PROJ string # https://projectionwizard.org   projection_Seychelles <- \"+proj=laea +lon_0=55 +lat_0=-4.5 +datum=WGS84 +units=m +no_defs\"  # check CRS if needed # sf::st_crs(projection_Seychelles)"},{"path":"/articles/minpatch-oceandatr-Seychelles.html","id":"create-a-planning-unit-grid","dir":"Articles","previous_headings":"2. Study region and planning units with oceandatr","what":"2.4 Create a planning-unit grid","title":"Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)","text":"now create grid EEZ. keep runtime moderate, use fairly coarse resolution. units meters.  cell Seychelles_grid planning unit. build prioritizr problem later, ’s useful vector version grid:","code":"# check which units to use # sf::st_crs(projection_Seychelles,  #           parameters = TRUE)$units_gdal  # grid the planning area Seychelles_grid <- get_grid(   boundary   = Seychelles_eez,   resolution = 30000, # 30,000 just to test the code but a finer resolution can be opted with a more powerful PC       crs        = projection_Seychelles)  # project the eez into same projection as grid for plotting Seychelles_eez_proj <- Seychelles_eez %>%   sf::st_transform(crs = projection_Seychelles) %>%   sf::st_geometry()  # plot the grid terra::plot(Seychelles_grid,              col = \"gold3\",              axes = FALSE,              legend = FALSE,             main = \"Seychelles spatial grid (30 km)\") plot(Seychelles_eez_proj,       add = TRUE,       border = \"black\",       lwd = 1) # convert grid to sf polygons as minpatch only works with sf Seychelles_pu <- Seychelles_grid %>%   stars::st_as_stars() %>%   sf::st_as_sf() %>%   dplyr::mutate(     id   = dplyr::row_number(),     cost = as.numeric(sf::st_area(.)) / 1e6  # cost = area in km²   ) %>%   dplyr::select(-layer)"},{"path":"/articles/minpatch-oceandatr-Seychelles.html","id":"building-marine-features-with-oceandatr","dir":"Articles","previous_headings":"","what":"3. Building marine features with oceandatr","title":"Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)","text":"use set features available oceandatr: bathymetric depth zones geomorphology - seafloor features (banks, ridges, etc.) knolls seamounts coral habitat environmental zones - clusters environmental conditions","code":""},{"path":"/articles/minpatch-oceandatr-Seychelles.html","id":"prepare-feature-stack","dir":"Articles","previous_headings":"3. Building marine features with oceandatr","what":"3.1 Prepare feature stack","title":"Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)","text":"layers can easily obtained using get_features function.","code":"# set seed for reproducibility in the get_enviro_zones() sampling to find optimal cluster number set.seed(500)  feature_set <- get_features(spatial_grid = Seychelles_grid) %>%   remove_empty_layers()    # tidy up feature data names for nicer mapping names(feature_set) <-  gsub(\"_\", \" \", names(feature_set)) %>% stringr::str_to_sentence()"},{"path":"/articles/minpatch-oceandatr-Seychelles.html","id":"plot-features","dir":"Articles","previous_headings":"3. Building marine features with oceandatr","what":"3.2 Plot features","title":"Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)","text":"Features visualised tmap. Planning units coloured blue feature present grey absent.","code":"library(tmap) library(terra) library(stringr)  names(feature_set) <- names(feature_set) %>%    gsub(\"_\", \" \", .) %>%    stringr::str_to_sentence()  feature_bin <- feature_set > 0  m <- tm_shape(feature_bin) +   tm_raster(     col.scale = tm_scale_categorical(       values = c(\"grey70\", \"royalblue\"),       labels = c(\"Absent\", \"Present\")     ),     col.legend = tm_legend_hide(),   # hide legend for this layer     col.free = FALSE   ) +   tm_facets(ncol = 4) +   tm_shape(Seychelles_eez) +   tm_borders() +   tm_layout(     panel.label.size = 1.5,     legend.show = FALSE )  m +   tm_add_legend(     type = \"fill\",     labels = c(\"Absent\", \"Present\"),     col = c(\"grey70\", \"royalblue\"),     title = \"\"   ) +   tm_layout(     legend.outside = TRUE,     legend.position = c(\"center\", \"bottom\"),     legend.text.size = 1   )"},{"path":"/articles/minpatch-oceandatr-Seychelles.html","id":"converting-features-to-sf-object-and-combining-it-with-the-pu-grid","dir":"Articles","previous_headings":"3. Building marine features with oceandatr","what":"3.3 Converting features to sf object and combining it with the PU grid","title":"Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)","text":"MinPatch works well sf objects, convert feature stack sf. Afterwards, put features grid one data table.","code":"# features to sf features <- feature_set %>%   stars::st_as_stars() %>% # convert data to sf   sf::st_as_sf() %>%   dplyr::mutate(id = dplyr::row_number()) %>%   sf::st_drop_geometry()  # combining  Seychelles_sf <- Seychelles_pu %>%   dplyr::left_join(     as.data.frame(features),     by = \"id\"   )  # store feature column names feature_set <- names(features) %>%   dplyr::setdiff(\"id\")"},{"path":"/articles/minpatch-oceandatr-Seychelles.html","id":"build-and-solve-a-prioritizr-problem","dir":"Articles","previous_headings":"","what":"4. Build and solve a prioritizr problem","title":"Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)","text":"now build simple minimum-set problem using prioritizr, equal-weight features uniform target 30% feature. solve baseline problem without fragmentation controls use reference MinPatch experiments.  baseline solution, see selected planning units fragmented scattered across planning region.","code":"# build the problem using sf planning units + feature columns p_base <-   prioritizr::problem(     x              = Seychelles_sf,     features       = feature_set,     cost_column    = \"cost\"   ) %>%   add_min_set_objective() %>%   add_relative_targets(0.30) %>% # 30% of each feature   add_binary_decisions() %>%   add_rsymphony_solver(verbose = FALSE) # change this to cbc later p_base #> A conservation problem (<ConservationProblem>) #> ├•data #> │├•features:    \"Continental shelf\", \"Upper bathyal\", \"Lower bathyal\", \"Abyssal\", … (28 total) #> │└•planning units: #> │ ├•data:       <sf> (1500 total) #> │ ├•costs:      continuous values (between 900.2126 and 900.2126) #> │ ├•extent:     -1301436, -912664.9, 511794.5, 457589 (xmin, ymin, xmax, ymax) #> │ └•CRS:        +proj=laea +lat_0=-4.5 +lon_0=55 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs (projected) #> ├•formulation #> │├•objective:   minimum set objective #> │├•penalties:   none specified #> │├•features: #> ││├•targets:    relative targets (all equal to 0.3) #> ││└•weights:    none specified #> │├•constraints: none specified #> │└•decisions:   binary decision #> └•optimization #>  ├•portfolio:   default portfolio #>  └•solver:      rsymphony solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) #> # ℹ Use `summary(...)` to see complete formulation. # solve the baseline problem t_base <- system.time({   s_base <- solve(p_base) })  # Plot the baseline solution p_base_plot <- plot_prioritizr(s_base) +   ggtitle(\"Baseline (no MinPatch)\")  p_base_plot"},{"path":"/articles/minpatch-oceandatr-Seychelles.html","id":"set-up-minpatch-parameters","dir":"Articles","previous_headings":"","what":"5. Set up MinPatch parameters","title":"Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)","text":"define minimum patch sizes relative planning units scaling median PU area multipliers (5×, 10×, 20×). makes thresholds easy interpret “roughly many planning units per patch”. also set single patch_radius runs, chosen represent neighbourhood 10 planning units. radius defines spatial search distance used MinPatch identify neighbouring planning units forming, expanding, merging patches.","code":"# median planning-unit area (m² and km²) median_pu_area_m2 <- median(st_area(Seychelles_sf)) median_pu_area_km2 <- median_pu_area_m2 / 1e6  # multipliers relative to the median PU area multipliers <- c(5, 10, 20)  # minimum patch sizes in m² and km² patch_sizes_m2  <- multipliers * median_pu_area_m2 patch_sizes_km2 <- patch_sizes_m2 / 1e6  # setting patch radius as the length of 10 PUs median_pu_length_m <- sqrt(median_pu_area_m2)  # set radius to 10 PU lengths patch_radius <- 10 * median_pu_length_m  # summary table minpatch_param_summary <- tibble::tibble(   multiplier       = multipliers,   min_patch_m2     = patch_sizes_m2,   min_patch_km2    = patch_sizes_km2,   median_pu_m2     = median_pu_area_m2,   median_pu_area_km2 = median_pu_area_km2)  # summaries of the different values cat(\"\\nMinPatch parameters (relative to planning units):\\n\") #>  #> MinPatch parameters (relative to planning units):  cat(\"- Median planning unit area:\",     round(median_pu_area_km2, 3), \"km^2\\n\\n\") #> - Median planning unit area: 900.213 km^2  for (i in seq_along(multipliers)) {   cat(\"Multiplier:\", multipliers[i], \"x median PU area\\n\")   cat(\"  - Minimum patch size:\",       round(patch_sizes_km2[i], 2), \"km^2\\n\")   cat(\"  - Corresponds to ≈\",       round(patch_sizes_km2[i] / median_pu_area_km2, 2),       \"planning units\\n\\n\") } #> Multiplier: 5 x median PU area #>   - Minimum patch size: 4501.06 km^2 #>   - Corresponds to ≈ 5 planning units #>  #> Multiplier: 10 x median PU area #>   - Minimum patch size: 9002.13 km^2 #>   - Corresponds to ≈ 10 planning units #>  #> Multiplier: 20 x median PU area #>   - Minimum patch size: 18004.25 km^2 #>   - Corresponds to ≈ 20 planning units  median_pu_length <- sqrt(median_pu_area_m2)      # ~ PU width (m) radius_in_pus <- patch_radius / median_pu_length # PU-widths  cat(\"Patch radius used for all runs:\\n\") #> Patch radius used for all runs: cat(\"  -\", round(patch_radius, 0), \"m (≈\", round(patch_radius/1000, 2), \"km)\\n\") #>   - 300035 m (≈ 300.04 km) cat(\"  - ≈\", round(radius_in_pus, 1), \"planning units outward (radius)\\n\") #>   - ≈ 10 planning units outward (radius)"},{"path":"/articles/minpatch-oceandatr-Seychelles.html","id":"run-minpatch-for-different-minimum-patch-sizes","dir":"Articles","previous_headings":"","what":"6. Run MinPatch for different minimum patch sizes","title":"Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)","text":"now run MinPatch minimum patch factor using different multipliers. run starts prioritizr solution applies different constraints minimum patch size.","code":"minpatch_results <- vector(\"list\", length(patch_sizes_m2)) minpatch_times <- numeric(length(patch_sizes_m2))  for (i in seq_along(patch_sizes_m2)) {    cat(\"\\n============================================\\n\") cat(\"Running MinPatch with min patch area ~\",     round(patch_sizes_km2[i], 2), \"km^2 (\",     multipliers[i], \"x median PU)\\n\") cat(\"============================================\\n\")      # time the MinPatch run   t_mp <- system.time({      minpatch_results[[i]] <- run_minpatch(     prioritizr_problem   = p_base,     prioritizr_solution  = s_base,     min_patch_size       = patch_sizes_m2[i],     patch_radius         = patch_radius,     boundary_penalty     = 0,     remove_small_patches = TRUE,     add_patches          = TRUE,     whittle_patches      = TRUE,     verbose              = TRUE   )        })     # store elapsed time (seconds)   minpatch_times[i] <- t_mp[[\"elapsed\"]] } #>  #> ============================================ #> Running MinPatch with min patch area ~ 4501.06 km^2 ( 5 x median PU) #> ============================================ #> Validating inputs... #> Initializing data structures... #> Calculating boundary matrix using 14 cores... #> Processing chunks in parallel... #> Combining results... #> Creating patch radius dictionary (optimized)... #> Processed 100 of 1500 planning units #> Processed 200 of 1500 planning units #> Processed 300 of 1500 planning units #> Processed 400 of 1500 planning units #> Processed 500 of 1500 planning units #> Processed 600 of 1500 planning units #> Processed 700 of 1500 planning units #> Processed 800 of 1500 planning units #> Processed 900 of 1500 planning units #> Processed 1000 of 1500 planning units #> Processed 1100 of 1500 planning units #> Processed 1200 of 1500 planning units #> Processed 1300 of 1500 planning units #> Processed 1400 of 1500 planning units #> Processed 1500 of 1500 planning units #> Calculating initial patch statistics... #> Stage 1: Removing small patches... #> Stage 2: Adding new patches... #>   Initial unmet targets: 22  #>   Unmet feature IDs: 1, 3, 4, 5, 6, 7, 8, 9, 11, 12, 14, 15, 16, 19, 20, 22, 23, 24, 25, 26, 27, 28  #>   Iteration 1 - Unmet targets: 22  #>     Found 1268 potential patches with scores #>     Best score: 0.0001156402 for unit 1035  #>     Added patch centered on unit 1035  #>   Iteration 2 - Unmet targets: 18  #>     Found 1188 potential patches with scores #>     Best score: 0.00009560689 for unit 1467  #>     Added patch centered on unit 1467  #>   Iteration 3 - Unmet targets: 8  #>     Found 1043 potential patches with scores #>     Best score: 0.00005491464 for unit 2  #>     Added patch centered on unit 2  #>   Iteration 4 - Unmet targets: 2  #>     Found 910 potential patches with scores #>     Best score: 0.00001454845 for unit 192  #>     Added patch centered on unit 192  #>   All conservation targets are now met! #> Stage 3: Removing unnecessary planning units... #>     Edge units found: 178  #>     Keystone units: 0  #>     New keystone units: 12  #>     Scoreable units: 166  #>     Removed unit 418 at iteration 1  #>     Edge units found: 167  #>     Keystone units: 12  #>     New keystone units: 0  #>     Scoreable units: 167  #>     Removed unit 383 at iteration 2  #>     Edge units found: 169  #>     Keystone units: 12  #>     New keystone units: 0  #>     Scoreable units: 169  #>     Removed unit 419 at iteration 3  #>     Edge units found: 169  #>     Keystone units: 12  #>     New keystone units: 0  #>     Scoreable units: 169  #>     Removed unit 420 at iteration 4  #>     Edge units found: 170  #>     Keystone units: 12  #>     New keystone units: 0  #>     Scoreable units: 170  #>     Removed unit 385 at iteration 5  #>     Removed unit 350 at iteration 6  #>     Unit 349 cannot be removed - adding to keystone set #>     Removed unit 351 at iteration 8  #>     Removed unit 317 at iteration 9  #>     Removed unit 283 at iteration 10  #>   Whittling iteration 100  #>   Whittling iteration 200  #>   Whittling iteration 300  #>   No units can be removed - all are keystone - terminating #> Calculating final statistics... #> MinPatch processing complete! #>  #> ============================================ #> Running MinPatch with min patch area ~ 9002.13 km^2 ( 10 x median PU) #> ============================================ #> Validating inputs... #> Initializing data structures... #> Calculating boundary matrix using 14 cores... #> Processing chunks in parallel... #> Combining results... #> Creating patch radius dictionary (optimized)... #> Processed 100 of 1500 planning units #> Processed 200 of 1500 planning units #> Processed 300 of 1500 planning units #> Processed 400 of 1500 planning units #> Processed 500 of 1500 planning units #> Processed 600 of 1500 planning units #> Processed 700 of 1500 planning units #> Processed 800 of 1500 planning units #> Processed 900 of 1500 planning units #> Processed 1000 of 1500 planning units #> Processed 1100 of 1500 planning units #> Processed 1200 of 1500 planning units #> Processed 1300 of 1500 planning units #> Processed 1400 of 1500 planning units #> Processed 1500 of 1500 planning units #> Calculating initial patch statistics... #> Stage 1: Removing small patches... #> Stage 2: Adding new patches... #>   Initial unmet targets: 24  #>   Unmet feature IDs: 1, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 18, 19, 20, 22, 23, 24, 25, 26, 27, 28  #>   Iteration 1 - Unmet targets: 24  #>     Found 1369 potential patches with scores #>     Best score: 0.00009068137 for unit 1456  #>     Added patch centered on unit 1456  #>   Iteration 2 - Unmet targets: 16  #>     Found 1188 potential patches with scores #>     Best score: 0.00008346697 for unit 1035  #>     Added patch centered on unit 1035  #>   Iteration 3 - Unmet targets: 8  #>     Found 1102 potential patches with scores #>     Best score: 0.00005543891 for unit 916  #>     Added patch centered on unit 916  #>   Iteration 4 - Unmet targets: 6  #>     Found 1025 potential patches with scores #>     Best score: 0.00004289114 for unit 1  #>     Added patch centered on unit 1  #>   Iteration 5 - Unmet targets: 1  #>     Found 480 potential patches with scores #>     Best score: 0.0000104797 for unit 484  #>     Added patch centered on unit 484  #>   All conservation targets are now met! #> Stage 3: Removing unnecessary planning units... #>     Edge units found: 151  #>     Keystone units: 0  #>     New keystone units: 1  #>     Scoreable units: 150  #>     Removed unit 172 at iteration 1  #>     Edge units found: 151  #>     Keystone units: 1  #>     New keystone units: 0  #>     Scoreable units: 151  #>     Removed unit 143 at iteration 2  #>     Edge units found: 153  #>     Keystone units: 1  #>     New keystone units: 0  #>     Scoreable units: 153  #>     Removed unit 142 at iteration 3  #>     Edge units found: 154  #>     Keystone units: 1  #>     New keystone units: 0  #>     Scoreable units: 154  #>     Removed unit 115 at iteration 4  #>     Edge units found: 155  #>     Keystone units: 1  #>     New keystone units: 0  #>     Scoreable units: 155  #>     Removed unit 114 at iteration 5  #>     Removed unit 171 at iteration 6  #>     Removed unit 173 at iteration 7  #>     Removed unit 181 at iteration 8  #>     Removed unit 182 at iteration 9  #>     Removed unit 183 at iteration 10  #>   Whittling iteration 100  #>   Whittling iteration 200  #>   No units can be removed - all are keystone - terminating #> Calculating final statistics... #> MinPatch processing complete! #>  #> ============================================ #> Running MinPatch with min patch area ~ 18004.25 km^2 ( 20 x median PU) #> ============================================ #> Validating inputs... #> Initializing data structures... #> Calculating boundary matrix using 14 cores... #> Processing chunks in parallel... #> Combining results... #> Creating patch radius dictionary (optimized)... #> Processed 100 of 1500 planning units #> Processed 200 of 1500 planning units #> Processed 300 of 1500 planning units #> Processed 400 of 1500 planning units #> Processed 500 of 1500 planning units #> Processed 600 of 1500 planning units #> Processed 700 of 1500 planning units #> Processed 800 of 1500 planning units #> Processed 900 of 1500 planning units #> Processed 1000 of 1500 planning units #> Processed 1100 of 1500 planning units #> Processed 1200 of 1500 planning units #> Processed 1300 of 1500 planning units #> Processed 1400 of 1500 planning units #> Processed 1500 of 1500 planning units #> Calculating initial patch statistics... #> Stage 1: Removing small patches... #> Stage 2: Adding new patches... #>   Initial unmet targets: 26  #>   Unmet feature IDs: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 19, 20, 22, 23, 24, 25, 26, 27, 28  #>   Iteration 1 - Unmet targets: 26  #>     Found 1433 potential patches with scores #>     Best score: 0.00008005606 for unit 1467  #>     Added patch centered on unit 1467  #>   Iteration 2 - Unmet targets: 21  #>     Found 1266 potential patches with scores #>     Best score: 0.00006988945 for unit 684  #>     Added patch centered on unit 684  #>   Iteration 3 - Unmet targets: 11  #>     Found 1103 potential patches with scores #>     Best score: 0.00005433364 for unit 916  #>     Added patch centered on unit 916  #>   Iteration 4 - Unmet targets: 8  #>     Found 1026 potential patches with scores #>     Best score: 0.00004598478 for unit 965  #>     Added patch centered on unit 965  #>   Iteration 5 - Unmet targets: 3  #>     Found 906 potential patches with scores #>     Best score: 0.00001719904 for unit 749  #>     Added patch centered on unit 749  #>   All conservation targets are now met! #> Stage 3: Removing unnecessary planning units... #>     Edge units found: 105  #>     Keystone units: 0  #>     New keystone units: 3  #>     Scoreable units: 102  #>     Removed unit 171 at iteration 1  #>     Edge units found: 102  #>     Keystone units: 3  #>     New keystone units: 0  #>     Scoreable units: 102  #>     Removed unit 172 at iteration 2  #>     Edge units found: 103  #>     Keystone units: 3  #>     New keystone units: 0  #>     Scoreable units: 103  #>     Removed unit 173 at iteration 3  #>     Edge units found: 104  #>     Keystone units: 3  #>     New keystone units: 0  #>     Scoreable units: 104  #>     Removed unit 174 at iteration 4  #>     Edge units found: 106  #>     Keystone units: 3  #>     New keystone units: 0  #>     Scoreable units: 106  #>     Removed unit 175 at iteration 5  #>     Removed unit 176 at iteration 6  #>     Removed unit 177 at iteration 7  #>     Removed unit 178 at iteration 8  #>     Removed unit 149 at iteration 9  #>     Removed unit 150 at iteration 10  #>   Whittling iteration 100  #>   Whittling iteration 200  #>   Whittling iteration 300  #>   Whittling iteration 400  #>   Whittling iteration 500  #>   No units can be removed - all are keystone - terminating #> Calculating final statistics... #> MinPatch processing complete!  # name the outputs names(minpatch_results) <- paste0(\"minpatch_\", multipliers, \"x\") names(minpatch_times)   <- paste0(\"minpatch_\", multipliers, \"x\")"},{"path":"/articles/minpatch-oceandatr-Seychelles.html","id":"interpreting-minpatch-outcomes","dir":"Articles","previous_headings":"","what":"7. Interpreting MinPatch outcomes","title":"Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)","text":"section, interpret MinPatch modifies baseline solution. compare resulting spatial patterns, patch structure, trade-offs fragmentation cost.","code":""},{"path":"/articles/minpatch-oceandatr-Seychelles.html","id":"selected-planning-units-baseline-vs-minpatch-runs","dir":"Articles","previous_headings":"7. Interpreting MinPatch outcomes","what":"7.1 Selected planning units (baseline vs MinPatch runs)","title":"Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)","text":"start showing selected planning units baseline MinPatch run. plot, can see baseline solution highly fragmented, many small isolated selected planning units. minimum patch size increases, small patches removed merged, leading fewer, larger, spatially coherent patches.","code":"# plot_solution_grid( #   results = minpatch_results, #   get_solution_fun = get_solution_with_solution1, #   subtitle_values = multipliers, #   title_prefix = \"MinPatch: \", #   value_label_fun = function(x) paste0(x, \"× median PU area\"), #   include_baseline = TRUE, #   baseline_solution = s_base, #   baseline_title = \"Baseline (prioritizr)\", #   ncol = 2 # )"},{"path":"/articles/minpatch-oceandatr-Seychelles.html","id":"group-summary-table-all-runs","dir":"Articles","previous_headings":"7. Interpreting MinPatch outcomes","what":"7.2 Group summary table (all runs)","title":"Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)","text":"examined spatial solutions, summarise runs single table compare outcomes across different metrics.  baseline solution highly fragmented (129 patches), patches failing minimum-size rule (21 valid). MinPatch applied, patches consolidate sharply: patch counts drop 28 (×5) 15 (×10) 8 (×20), remaining patches valid every multiplier. multiplier increases, patch sizes rise well beyond threshold, showing progressively stronger spatial consolidation fewer, larger patches.","code":""},{"path":"/articles/minpatch-oceandatr-Seychelles.html","id":"change-maps-added-removed-retained-no-change","dir":"Articles","previous_headings":"7. Interpreting MinPatch outcomes","what":"7.3 Change maps (Added / Removed / Retained / No change)","title":"Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)","text":"comparing runs, use plot_minpatch map planning units added, removed, kept versus baseline. maps show MinPatch reshapes solution meet minimum patch sizes cut fragmentation.","code":"# Create plots for each minpatch run and arrange them with patchwork plot_list <- purrr::map2(   minpatch_results,   multipliers,   ~ plot_minpatch(       .x,       title = paste0(\"Patch size x\", .y)     ) ) patchwork::wrap_plots(   plotlist = plot_list,   guides   = \"collect\",   ncol     = 3 ) &   theme(legend.position = \"bottom\")"},{"path":"/articles/minpatch-oceandatr-Seychelles.html","id":"patch-labelled-maps","dir":"Articles","previous_headings":"7. Interpreting MinPatch outcomes","what":"7.4 Patch-labelled maps","title":"Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)","text":"use function labels patches MinPatch solutions flags one valid (meets minimum patch-size rule) invalid (threshold; exist). makes patch definition explicit helps interpret patch counts summary table. Patch counts depend “connected” defined. MinPatch uses rook adjacency, planning units must share edge patch. contrast, queen adjacency also treats corner-touching (diagonal) units connected. ecology management, rook-connected patches often defensible represent truly contiguous area, avoid corner-links, tend form compact patch units.","code":"for (m in c(5, 10, 20)) {   print(minpatch::plot_patch_validity(     multiplier = m,     multipliers = multipliers,     minpatch_results = minpatch_results,     pu_sf = Seychelles_sf,     do_snap = FALSE   )) } #> MinPatch 5x: 23 patches | 23 valid | 0 invalid (threshold = 4501.063 km²) | snap = FALSE #> MinPatch 10x: 11 patches | 11 valid | 0 invalid (threshold = 9002.126 km²) | snap = FALSE #> MinPatch 20x: 11 patches | 11 valid | 0 invalid (threshold = 18004.25 km²) | snap = FALSE"},{"path":"/articles/minpatch-oceandatr-Seychelles.html","id":"individual-summaries-per-run","dir":"Articles","previous_headings":"7. Interpreting MinPatch outcomes","what":"7.5 Individual summaries (per run)","title":"Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)","text":", show individual summaries runs. provide detailed breakdown comparison metrics minimum patch run baseline solution, well information feature level area comparison feature change summaries. Notes: calculation valid invalid patches rechecked. planning unit cost calculated baseline? differ every summary table (.e., table multiplier)? Add units Total Area (km2 m2?)","code":"for (i in seq_along(minpatch_results)) {    result <- minpatch_results[[i]]   factor_val <- multipliers[i]    cat(\"\\n\\n## Scenario: MinPatch with min patch size = \",       factor_val, \" × median PU area\\n\\n\", sep = \"\")    # MinPatch summary (if it prints text)   cat(\"**MinPatch processing summary**\\n\\n\")   print_minpatch_summary(result)    comparison <- compare_solutions(result)    cat(\"\\n**Overall solution comparison**\\n\\n\") print(comparison$overall)    cat(\"\\n**Feature-level area comparison**\\n\\n\") print(comparison$features)    cat(\"\\n**Feature change summary**\\n\\n\") print(comparison$summary) } #>  #>  #> ## Scenario: MinPatch with min patch size = 5 × median PU area #>  #> **MinPatch processing summary** #>  #> === MinPatch Processing Summary === #>  #> Patch Statistics: #>   Initial patches: 146 (valid: 22) #>   Final patches: 23 (valid: 23) #>   Area change: 2700637750.93 (0.7%) #>  #> Cost Breakdown: #>   Planning unit cost: 410496.94 #>   Boundary cost: 0.00 #>   Total cost: 410496.94 #>   Selected units: 456 #>  #> Feature Representation: #>   Total features: 28 #>   Targets met: 28 #>   Targets unmet: 0 #>   Mean proportion: 0.376 #>   Total shortfall: 0.00 #>  #>  #> === End Summary === #>  #> **Overall solution comparison** #>  #>                        Metric       Original       MinPatch     Change #> 1     Selected Planning Units          453.0          456.0          3 #> 2                  Total Area 407796300391.2 410496938142.2 2700637751 #> 3           Number of Patches          146.0           23.0       -123 #> 4 Valid Patches (>= min size)           22.0           23.0          1 #> 5           Median Patch Size   1800425167.3   5401275501.9 3600850335 #> 6          Planning Unit Cost       410496.9       410496.9          0 #> 7               Boundary Cost            0.0            0.0          0 #> 8                  Total Cost       410496.9       410496.9          0 #>   Percent_Change #> 1      0.6622517 #> 2      0.6622517 #> 3    -84.2465753 #> 4      4.5454545 #> 5    200.0000000 #> 6      0.0000000 #> 7             NA #> 8      0.0000000 #>  #> **Feature-level area comparison** #>  #>    Feature_ID Target Original_Area MinPatch_Area Area_Change Percent_Change #> 1           1   11.1            12            12           0      0.0000000 #> 2           2    4.5             5             7           2     40.0000000 #> 3           3  110.1           111           112           1      0.9009009 #> 4           4  324.3           325           325           0      0.0000000 #> 5           5   86.1            93            87          -6     -6.4516129 #> 6           6   45.9            46            59          13     28.2608696 #> 7           7  163.2           175           178           3      1.7142857 #> 8           8  116.1           125           123          -2     -1.6000000 #> 9           9    0.6             1             1           0      0.0000000 #> 10         10    0.6             1             1           0      0.0000000 #> 11         11   23.1            30            28          -2     -6.6666667 #> 12         12    2.1             4             3          -1    -25.0000000 #> 13         13    3.3             5             4          -1    -20.0000000 #> 14         14  158.7           179           171          -8     -4.4692737 #> 15         15   64.5            67            80          13     19.4029851 #> 16         16   20.7            25            22          -3    -12.0000000 #> 17         17    2.1             3             3           0      0.0000000 #> 18         18   22.5            42            34          -8    -19.0476190 #> 19         19    0.6             1             1           0      0.0000000 #> 20         20   14.4            19            17          -2    -10.5263158 #> 21         21    3.9             6             6           0      0.0000000 #> 22         22   63.9            75            91          16     21.3333333 #> 23         23    6.3             7             8           1     14.2857143 #> 24         24   51.3            53            67          14     26.4150943 #> 25         25  137.7           138           139           1      0.7246377 #> 26         26  150.0           152           150          -2     -1.3157895 #> 27         27   74.4            75            75           0      0.0000000 #> 28         28   87.9            88            92           4      4.5454545 #>    Original_Target_Met MinPatch_Target_Met Original_Proportion #> 1                 TRUE                TRUE            1.081081 #> 2                 TRUE                TRUE            1.111111 #> 3                 TRUE                TRUE            1.008174 #> 4                 TRUE                TRUE            1.002158 #> 5                 TRUE                TRUE            1.080139 #> 6                 TRUE                TRUE            1.002179 #> 7                 TRUE                TRUE            1.072304 #> 8                 TRUE                TRUE            1.076658 #> 9                 TRUE                TRUE            1.666667 #> 10                TRUE                TRUE            1.666667 #> 11                TRUE                TRUE            1.298701 #> 12                TRUE                TRUE            1.904762 #> 13                TRUE                TRUE            1.515152 #> 14                TRUE                TRUE            1.127914 #> 15                TRUE                TRUE            1.038760 #> 16                TRUE                TRUE            1.207729 #> 17                TRUE                TRUE            1.428571 #> 18                TRUE                TRUE            1.866667 #> 19                TRUE                TRUE            1.666667 #> 20                TRUE                TRUE            1.319444 #> 21                TRUE                TRUE            1.538462 #> 22                TRUE                TRUE            1.173709 #> 23                TRUE                TRUE            1.111111 #> 24                TRUE                TRUE            1.033138 #> 25                TRUE                TRUE            1.002179 #> 26                TRUE                TRUE            1.013333 #> 27                TRUE                TRUE            1.008065 #> 28                TRUE                TRUE            1.001138 #>    MinPatch_Proportion #> 1             1.081081 #> 2             1.555556 #> 3             1.017257 #> 4             1.002158 #> 5             1.010453 #> 6             1.285403 #> 7             1.090686 #> 8             1.059432 #> 9             1.666667 #> 10            1.666667 #> 11            1.212121 #> 12            1.428571 #> 13            1.212121 #> 14            1.077505 #> 15            1.240310 #> 16            1.062802 #> 17            1.428571 #> 18            1.511111 #> 19            1.666667 #> 20            1.180556 #> 21            1.538462 #> 22            1.424100 #> 23            1.269841 #> 24            1.306043 #> 25            1.009441 #> 26            1.000000 #> 27            1.008065 #> 28            1.046644 #>  #> **Feature change summary** #>  #>   features_improved features_reduced features_unchanged targets_gained #> 1                10               10                  8              0 #>   targets_lost #> 1            0 #>  #>  #> ## Scenario: MinPatch with min patch size = 10 × median PU area #>  #> **MinPatch processing summary** #>  #> === MinPatch Processing Summary === #>  #> Patch Statistics: #>   Initial patches: 146 (valid: 8) #>   Final patches: 11 (valid: 11) #>   Area change: 11702763587.39 (2.9%) #>  #> Cost Breakdown: #>   Planning unit cost: 419499.06 #>   Boundary cost: 0.00 #>   Total cost: 419499.06 #>   Selected units: 466 #>  #> Feature Representation: #>   Total features: 28 #>   Targets met: 28 #>   Targets unmet: 0 #>   Mean proportion: 0.439 #>   Total shortfall: 0.00 #>  #>  #> === End Summary === #>  #> **Overall solution comparison** #>  #>                        Metric       Original       MinPatch      Change #> 1     Selected Planning Units          453.0          466.0          13 #> 2                  Total Area 407796300391.2 419499063978.6 11702763587 #> 3           Number of Patches          146.0           11.0        -135 #> 4 Valid Patches (>= min size)            8.0           11.0           3 #> 5           Median Patch Size   1800425167.3   9902338420.1  8101913253 #> 6          Planning Unit Cost       419499.1       419499.1           0 #> 7               Boundary Cost            0.0            0.0           0 #> 8                  Total Cost       419499.1       419499.1           0 #>   Percent_Change #> 1       2.869757 #> 2       2.869757 #> 3     -92.465753 #> 4      37.500000 #> 5     450.000000 #> 6       0.000000 #> 7             NA #> 8       0.000000 #>  #> **Feature-level area comparison** #>  #>    Feature_ID Target Original_Area MinPatch_Area Area_Change Percent_Change #> 1           1   11.1            12            12           0      0.0000000 #> 2           2    4.5             5             6           1     20.0000000 #> 3           3  110.1           111           123          12     10.8108108 #> 4           4  324.3           325           325           0      0.0000000 #> 5           5   86.1            93            87          -6     -6.4516129 #> 6           6   45.9            46            49           3      6.5217391 #> 7           7  163.2           175           169          -6     -3.4285714 #> 8           8  116.1           125           146          21     16.8000000 #> 9           9    0.6             1             1           0      0.0000000 #> 10         10    0.6             1             2           1    100.0000000 #> 11         11   23.1            30            24          -6    -20.0000000 #> 12         12    2.1             4             5           1     25.0000000 #> 13         13    3.3             5             5           0      0.0000000 #> 14         14  158.7           179           160         -19    -10.6145251 #> 15         15   64.5            67            70           3      4.4776119 #> 16         16   20.7            25            21          -4    -16.0000000 #> 17         17    2.1             3             4           1     33.3333333 #> 18         18   22.5            42            66          24     57.1428571 #> 19         19    0.6             1             1           0      0.0000000 #> 20         20   14.4            19            23           4     21.0526316 #> 21         21    3.9             6             9           3     50.0000000 #> 22         22   63.9            75            84           9     12.0000000 #> 23         23    6.3             7            12           5     71.4285714 #> 24         24   51.3            53            62           9     16.9811321 #> 25         25  137.7           138           139           1      0.7246377 #> 26         26  150.0           152           150          -2     -1.3157895 #> 27         27   74.4            75            75           0      0.0000000 #> 28         28   87.9            88           102          14     15.9090909 #>    Original_Target_Met MinPatch_Target_Met Original_Proportion #> 1                 TRUE                TRUE            1.081081 #> 2                 TRUE                TRUE            1.111111 #> 3                 TRUE                TRUE            1.008174 #> 4                 TRUE                TRUE            1.002158 #> 5                 TRUE                TRUE            1.080139 #> 6                 TRUE                TRUE            1.002179 #> 7                 TRUE                TRUE            1.072304 #> 8                 TRUE                TRUE            1.076658 #> 9                 TRUE                TRUE            1.666667 #> 10                TRUE                TRUE            1.666667 #> 11                TRUE                TRUE            1.298701 #> 12                TRUE                TRUE            1.904762 #> 13                TRUE                TRUE            1.515152 #> 14                TRUE                TRUE            1.127914 #> 15                TRUE                TRUE            1.038760 #> 16                TRUE                TRUE            1.207729 #> 17                TRUE                TRUE            1.428571 #> 18                TRUE                TRUE            1.866667 #> 19                TRUE                TRUE            1.666667 #> 20                TRUE                TRUE            1.319444 #> 21                TRUE                TRUE            1.538462 #> 22                TRUE                TRUE            1.173709 #> 23                TRUE                TRUE            1.111111 #> 24                TRUE                TRUE            1.033138 #> 25                TRUE                TRUE            1.002179 #> 26                TRUE                TRUE            1.013333 #> 27                TRUE                TRUE            1.008065 #> 28                TRUE                TRUE            1.001138 #>    MinPatch_Proportion #> 1             1.081081 #> 2             1.333333 #> 3             1.117166 #> 4             1.002158 #> 5             1.010453 #> 6             1.067538 #> 7             1.035539 #> 8             1.257537 #> 9             1.666667 #> 10            3.333333 #> 11            1.038961 #> 12            2.380952 #> 13            1.515152 #> 14            1.008192 #> 15            1.085271 #> 16            1.014493 #> 17            1.904762 #> 18            2.933333 #> 19            1.666667 #> 20            1.597222 #> 21            2.307692 #> 22            1.314554 #> 23            1.904762 #> 24            1.208577 #> 25            1.009441 #> 26            1.000000 #> 27            1.008065 #> 28            1.160410 #>  #> **Feature change summary** #>  #>   features_improved features_reduced features_unchanged targets_gained #> 1                16                6                  6              0 #>   targets_lost #> 1            0 #>  #>  #> ## Scenario: MinPatch with min patch size = 20 × median PU area #>  #> **MinPatch processing summary** #>  #> === MinPatch Processing Summary === #>  #> Patch Statistics: #>   Initial patches: 146 (valid: 3) #>   Final patches: 11 (valid: 11) #>   Area change: 34208078178.51 (8.4%) #>  #> Cost Breakdown: #>   Planning unit cost: 442004.38 #>   Boundary cost: 0.00 #>   Total cost: 442004.38 #>   Selected units: 491 #>  #> Feature Representation: #>   Total features: 28 #>   Targets met: 28 #>   Targets unmet: 0 #>   Mean proportion: 0.465 #>   Total shortfall: 0.00 #>  #>  #> === End Summary === #>  #> **Overall solution comparison** #>  #>                        Metric       Original       MinPatch      Change #> 1     Selected Planning Units          453.0          491.0          38 #> 2                  Total Area 407796300391.2 442004378569.8 34208078179 #> 3           Number of Patches          146.0           11.0        -135 #> 4 Valid Patches (>= min size)            3.0           11.0           8 #> 5           Median Patch Size   1800425167.3  22505314591.1 20704889424 #> 6          Planning Unit Cost       442004.4       442004.4           0 #> 7               Boundary Cost            0.0            0.0           0 #> 8                  Total Cost       442004.4       442004.4           0 #>   Percent_Change #> 1       8.388521 #> 2       8.388521 #> 3     -92.465753 #> 4     266.666667 #> 5    1150.000000 #> 6       0.000000 #> 7             NA #> 8       0.000000 #>  #> **Feature-level area comparison** #>  #>    Feature_ID Target Original_Area MinPatch_Area Area_Change Percent_Change #> 1           1   11.1            12            14           2      16.666667 #> 2           2    4.5             5             9           4      80.000000 #> 3           3  110.1           111           143          32      28.828829 #> 4           4  324.3           325           325           0       0.000000 #> 5           5   86.1            93            98           5       5.376344 #> 6           6   45.9            46            66          20      43.478261 #> 7           7  163.2           175           181           6       3.428571 #> 8           8  116.1           125           133           8       6.400000 #> 9           9    0.6             1             1           0       0.000000 #> 10         10    0.6             1             2           1     100.000000 #> 11         11   23.1            30            29          -1      -3.333333 #> 12         12    2.1             4             6           2      50.000000 #> 13         13    3.3             5             5           0       0.000000 #> 14         14  158.7           179           160         -19     -10.614525 #> 15         15   64.5            67            82          15      22.388060 #> 16         16   20.7            25            29           4      16.000000 #> 17         17    2.1             3             3           0       0.000000 #> 18         18   22.5            42            47           5      11.904762 #> 19         19    0.6             1             2           1     100.000000 #> 20         20   14.4            19            17          -2     -10.526316 #> 21         21    3.9             6             5          -1     -16.666667 #> 22         22   63.9            75            95          20      26.666667 #> 23         23    6.3             7            12           5      71.428571 #> 24         24   51.3            53            80          27      50.943396 #> 25         25  137.7           138           152          14      10.144928 #> 26         26  150.0           152           150          -2      -1.315789 #> 27         27   74.4            75            76           1       1.333333 #> 28         28   87.9            88           113          25      28.409091 #>    Original_Target_Met MinPatch_Target_Met Original_Proportion #> 1                 TRUE                TRUE            1.081081 #> 2                 TRUE                TRUE            1.111111 #> 3                 TRUE                TRUE            1.008174 #> 4                 TRUE                TRUE            1.002158 #> 5                 TRUE                TRUE            1.080139 #> 6                 TRUE                TRUE            1.002179 #> 7                 TRUE                TRUE            1.072304 #> 8                 TRUE                TRUE            1.076658 #> 9                 TRUE                TRUE            1.666667 #> 10                TRUE                TRUE            1.666667 #> 11                TRUE                TRUE            1.298701 #> 12                TRUE                TRUE            1.904762 #> 13                TRUE                TRUE            1.515152 #> 14                TRUE                TRUE            1.127914 #> 15                TRUE                TRUE            1.038760 #> 16                TRUE                TRUE            1.207729 #> 17                TRUE                TRUE            1.428571 #> 18                TRUE                TRUE            1.866667 #> 19                TRUE                TRUE            1.666667 #> 20                TRUE                TRUE            1.319444 #> 21                TRUE                TRUE            1.538462 #> 22                TRUE                TRUE            1.173709 #> 23                TRUE                TRUE            1.111111 #> 24                TRUE                TRUE            1.033138 #> 25                TRUE                TRUE            1.002179 #> 26                TRUE                TRUE            1.013333 #> 27                TRUE                TRUE            1.008065 #> 28                TRUE                TRUE            1.001138 #>    MinPatch_Proportion #> 1             1.261261 #> 2             2.000000 #> 3             1.298819 #> 4             1.002158 #> 5             1.138211 #> 6             1.437908 #> 7             1.109069 #> 8             1.145564 #> 9             1.666667 #> 10            3.333333 #> 11            1.255411 #> 12            2.857143 #> 13            1.515152 #> 14            1.008192 #> 15            1.271318 #> 16            1.400966 #> 17            1.428571 #> 18            2.088889 #> 19            3.333333 #> 20            1.180556 #> 21            1.282051 #> 22            1.486698 #> 23            1.904762 #> 24            1.559454 #> 25            1.103849 #> 26            1.000000 #> 27            1.021505 #> 28            1.285552 #>  #> **Feature change summary** #>  #>   features_improved features_reduced features_unchanged targets_gained #> 1                19                5                  4              0 #>   targets_lost #> 1            0"},{"path":"/articles/minpatch-oceandatr-Seychelles.html","id":"run-different-boundary-penalties","dir":"Articles","previous_headings":"","what":"8. Run different boundary penalties","title":"Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)","text":"boundary penalty controls strongly MinPatch favours spatially compact patches whittling stage. step, MinPatch attempts remove planning units edges patches maintaining conservation targets. Whether unit can removed depends trade-planning-unit cost change boundary cost result removal. boundary penalty scales trade-assigning cost fragmentation: higher values discourage creation additional patch edges therefore promote compact solutions. Seychelles example, explore small range boundary penalties illustrate sensitive whittling process boundary costs marine grid relatively uniform planning-unit areas.","code":"# calculate reasonable parameters based on planning unit characteristics median_area <- median(st_area(Seychelles_sf))  min_patch_size <- median_area * 5 patch_radius <- sqrt(median_area * 10/pi)  bp3 = 0 t3 <- system.time({  result3 <- run_minpatch(   prioritizr_problem = p_base,   prioritizr_solution = s_base,   min_patch_size = min_patch_size,   patch_radius = patch_radius,   boundary_penalty = bp3,   remove_small_patches = TRUE,   add_patches = TRUE,   whittle_patches = TRUE,   verbose = TRUE )  }) #> Validating inputs... #> Initializing data structures... #> Calculating boundary matrix using 14 cores... #> Processing chunks in parallel... #> Combining results... #> Creating patch radius dictionary (optimized)... #> Processed 100 of 1500 planning units #> Processed 200 of 1500 planning units #> Processed 300 of 1500 planning units #> Processed 400 of 1500 planning units #> Processed 500 of 1500 planning units #> Processed 600 of 1500 planning units #> Processed 700 of 1500 planning units #> Processed 800 of 1500 planning units #> Processed 900 of 1500 planning units #> Processed 1000 of 1500 planning units #> Processed 1100 of 1500 planning units #> Processed 1200 of 1500 planning units #> Processed 1300 of 1500 planning units #> Processed 1400 of 1500 planning units #> Processed 1500 of 1500 planning units #> Calculating initial patch statistics... #> Stage 1: Removing small patches... #> Stage 2: Adding new patches... #>   Initial unmet targets: 22  #>   Unmet feature IDs: 1, 3, 4, 5, 6, 7, 8, 9, 11, 12, 14, 15, 16, 19, 20, 22, 23, 24, 25, 26, 27, 28  #>   Iteration 1 - Unmet targets: 22  #>     Found 1268 potential patches with scores #>     Best score: 0.0006018207 for unit 715  #>     Added patch centered on unit 715  #>   Iteration 2 - Unmet targets: 21  #>     Found 1266 potential patches with scores #>     Best score: 0.0005272466 for unit 568  #>     Added patch centered on unit 568  #>   Iteration 3 - Unmet targets: 20  #>     Found 1259 potential patches with scores #>     Best score: 0.0004467726 for unit 397  #>     Added patch centered on unit 397  #>   Iteration 4 - Unmet targets: 19  #>     Found 1255 potential patches with scores #>     Best score: 0.0004979957 for unit 1293  #>     Added patch centered on unit 1293  #>   Iteration 5 - Unmet targets: 19  #>     Found 1251 potential patches with scores #>     Best score: 0.0005055629 for unit 1220  #>     Added patch centered on unit 1220  #>   Iteration 10 - Unmet targets: 12  #>   Iteration 20 - Unmet targets: 9  #>   Iteration 30 - Unmet targets: 4  #>   Iteration 40 - Unmet targets: 2  #>   All conservation targets are now met! #> Stage 3: Removing unnecessary planning units... #>     Edge units found: 341  #>     Keystone units: 0  #>     New keystone units: 60  #>     Scoreable units: 281  #>     Removed unit 1256 at iteration 1  #>     Edge units found: 281  #>     Keystone units: 60  #>     New keystone units: 0  #>     Scoreable units: 281  #>     Unit 1276 cannot be removed - adding to keystone set #>     Edge units found: 280  #>     Keystone units: 61  #>     New keystone units: 0  #>     Scoreable units: 280  #>     Unit 1277 cannot be removed - adding to keystone set #>     Edge units found: 279  #>     Keystone units: 62  #>     New keystone units: 0  #>     Scoreable units: 279  #>     Removed unit 1292 at iteration 4  #>     Edge units found: 280  #>     Keystone units: 62  #>     New keystone units: 0  #>     Scoreable units: 280  #>     Removed unit 1293 at iteration 5  #>     Removed unit 1219 at iteration 6  #>     Removed unit 1220 at iteration 7  #>     Removed unit 1257 at iteration 8  #>     Removed unit 395 at iteration 9  #>     Removed unit 1258 at iteration 10  #>   No units can be removed - all are keystone - terminating #> Calculating final statistics... #> MinPatch processing complete! cat(\"result3 runtime (sec):\", t3[[\"elapsed\"]], \"\\n\") #> result3 runtime (sec): 35.249  bp4 = 0.00001 t4 <- system.time({   result4 <- run_minpatch(   prioritizr_problem = p_base,   prioritizr_solution = s_base,   min_patch_size = min_patch_size,   patch_radius = patch_radius,   boundary_penalty = bp4,   remove_small_patches = TRUE,   add_patches = TRUE,   whittle_patches = TRUE,   verbose = TRUE ) }) #> Validating inputs... #> Initializing data structures... #> Calculating boundary matrix using 14 cores... #> Processing chunks in parallel... #> Combining results... #> Creating patch radius dictionary (optimized)... #> Processed 100 of 1500 planning units #> Processed 200 of 1500 planning units #> Processed 300 of 1500 planning units #> Processed 400 of 1500 planning units #> Processed 500 of 1500 planning units #> Processed 600 of 1500 planning units #> Processed 700 of 1500 planning units #> Processed 800 of 1500 planning units #> Processed 900 of 1500 planning units #> Processed 1000 of 1500 planning units #> Processed 1100 of 1500 planning units #> Processed 1200 of 1500 planning units #> Processed 1300 of 1500 planning units #> Processed 1400 of 1500 planning units #> Processed 1500 of 1500 planning units #> Calculating initial patch statistics... #> Stage 1: Removing small patches... #> Stage 2: Adding new patches... #>   Initial unmet targets: 22  #>   Unmet feature IDs: 1, 3, 4, 5, 6, 7, 8, 9, 11, 12, 14, 15, 16, 19, 20, 22, 23, 24, 25, 26, 27, 28  #>   Iteration 1 - Unmet targets: 22  #>     Found 1268 potential patches with scores #>     Best score: 0.0006018207 for unit 715  #>     Added patch centered on unit 715  #>   Iteration 2 - Unmet targets: 21  #>     Found 1266 potential patches with scores #>     Best score: 0.0005272466 for unit 568  #>     Added patch centered on unit 568  #>   Iteration 3 - Unmet targets: 20  #>     Found 1259 potential patches with scores #>     Best score: 0.0004467726 for unit 397  #>     Added patch centered on unit 397  #>   Iteration 4 - Unmet targets: 19  #>     Found 1255 potential patches with scores #>     Best score: 0.0004979957 for unit 1293  #>     Added patch centered on unit 1293  #>   Iteration 5 - Unmet targets: 19  #>     Found 1251 potential patches with scores #>     Best score: 0.0005055629 for unit 1220  #>     Added patch centered on unit 1220  #>   Iteration 10 - Unmet targets: 12  #>   Iteration 20 - Unmet targets: 9  #>   Iteration 30 - Unmet targets: 4  #>   Iteration 40 - Unmet targets: 2  #>   All conservation targets are now met! #> Stage 3: Removing unnecessary planning units... #>     Edge units found: 341  #>     Keystone units: 0  #>     New keystone units: 60  #>     Scoreable units: 281  #>     Removed unit 1256 at iteration 1  #>     Edge units found: 281  #>     Keystone units: 60  #>     New keystone units: 0  #>     Scoreable units: 281  #>     Unit 1276 cannot be removed - adding to keystone set #>     Edge units found: 280  #>     Keystone units: 61  #>     New keystone units: 0  #>     Scoreable units: 280  #>     Unit 1277 cannot be removed - adding to keystone set #>     Edge units found: 279  #>     Keystone units: 62  #>     New keystone units: 0  #>     Scoreable units: 279  #>     Removed unit 1292 at iteration 4  #>     Edge units found: 280  #>     Keystone units: 62  #>     New keystone units: 0  #>     Scoreable units: 280  #>     Removed unit 1293 at iteration 5  #>     Removed unit 1219 at iteration 6  #>     Removed unit 1220 at iteration 7  #>     Removed unit 1257 at iteration 8  #>     Removed unit 395 at iteration 9  #>     Removed unit 1258 at iteration 10  #>   No units can be removed - all are keystone - terminating #> Calculating final statistics... #> MinPatch processing complete! cat(\"result4 runtime (sec):\", t4[[\"elapsed\"]], \"\\n\") #> result4 runtime (sec): 35.78  bp5 = 1 t5 <- system.time({   result5 <- run_minpatch(   prioritizr_problem = p_base,   prioritizr_solution = s_base,   min_patch_size = min_patch_size,   patch_radius = patch_radius,   boundary_penalty = bp5,    remove_small_patches = TRUE,   add_patches = TRUE,   whittle_patches = TRUE,   verbose = TRUE ) }) #> Validating inputs... #> Initializing data structures... #> Calculating boundary matrix using 14 cores... #> Processing chunks in parallel... #> Combining results... #> Creating patch radius dictionary (optimized)... #> Processed 100 of 1500 planning units #> Processed 200 of 1500 planning units #> Processed 300 of 1500 planning units #> Processed 400 of 1500 planning units #> Processed 500 of 1500 planning units #> Processed 600 of 1500 planning units #> Processed 700 of 1500 planning units #> Processed 800 of 1500 planning units #> Processed 900 of 1500 planning units #> Processed 1000 of 1500 planning units #> Processed 1100 of 1500 planning units #> Processed 1200 of 1500 planning units #> Processed 1300 of 1500 planning units #> Processed 1400 of 1500 planning units #> Processed 1500 of 1500 planning units #> Calculating initial patch statistics... #> Stage 1: Removing small patches... #> Stage 2: Adding new patches... #>   Initial unmet targets: 22  #>   Unmet feature IDs: 1, 3, 4, 5, 6, 7, 8, 9, 11, 12, 14, 15, 16, 19, 20, 22, 23, 24, 25, 26, 27, 28  #>   Iteration 1 - Unmet targets: 22  #>     Found 1268 potential patches with scores #>     Best score: 0.0006018207 for unit 715  #>     Added patch centered on unit 715  #>   Iteration 2 - Unmet targets: 21  #>     Found 1266 potential patches with scores #>     Best score: 0.0005272466 for unit 568  #>     Added patch centered on unit 568  #>   Iteration 3 - Unmet targets: 20  #>     Found 1259 potential patches with scores #>     Best score: 0.0004467726 for unit 397  #>     Added patch centered on unit 397  #>   Iteration 4 - Unmet targets: 19  #>     Found 1255 potential patches with scores #>     Best score: 0.0004979957 for unit 1293  #>     Added patch centered on unit 1293  #>   Iteration 5 - Unmet targets: 19  #>     Found 1251 potential patches with scores #>     Best score: 0.0005055629 for unit 1220  #>     Added patch centered on unit 1220  #>   Iteration 10 - Unmet targets: 12  #>   Iteration 20 - Unmet targets: 9  #>   Iteration 30 - Unmet targets: 4  #>   Iteration 40 - Unmet targets: 2  #>   All conservation targets are now met! #> Stage 3: Removing unnecessary planning units... #>     Edge units found: 341  #>     Keystone units: 0  #>     New keystone units: 60  #>     Scoreable units: 281  #>     Unit 1256 cannot be removed - adding to keystone set #>     Edge units found: 280  #>     Keystone units: 61  #>     New keystone units: 0  #>     Scoreable units: 280  #>     Unit 1276 cannot be removed - adding to keystone set #>     Edge units found: 279  #>     Keystone units: 62  #>     New keystone units: 0  #>     Scoreable units: 279  #>     Unit 1277 cannot be removed - adding to keystone set #>     Edge units found: 278  #>     Keystone units: 63  #>     New keystone units: 0  #>     Scoreable units: 278  #>     Unit 1292 cannot be removed - adding to keystone set #>     Edge units found: 277  #>     Keystone units: 64  #>     New keystone units: 0  #>     Scoreable units: 277  #>     Unit 1311 cannot be removed - adding to keystone set #>     Unit 1357 cannot be removed - adding to keystone set #>     Unit 1389 cannot be removed - adding to keystone set #>     Unit 1390 cannot be removed - adding to keystone set #>     Unit 1361 cannot be removed - adding to keystone set #>     Unit 1219 cannot be removed - adding to keystone set #>   Whittling iteration 100  #>   Whittling iteration 200  #>   No more edge units to consider - terminating #> Calculating final statistics... #> MinPatch processing complete! cat(\"result5 runtime (sec):\", t5[[\"elapsed\"]], \"\\n\") #> result5 runtime (sec): 50.855"},{"path":[]},{"path":"/articles/minpatch-oceandatr-Seychelles.html","id":"change-maps-added-removed-retained-no-change-1","dir":"Articles","previous_headings":"9. Interpreting MinPatch with boundary penalties outcomes","what":"9.1 Change maps (Added / Removed / Retained / No change)","title":"Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)","text":", visualise MinPatch solutions different boundary penalty values.  resulting plots identical.","code":"patchwork::wrap_plots(plot_minpatch(result3, title = paste0(\"Boundary Penalty: \", bp3)),                       plot_minpatch(result4, title = paste0(\"Boundary Penalty: \", bp4)),                       plot_minpatch(result5, title = paste0(\"Boundary Penalty: \", bp5)),                       guides = \"collect\",                       ncol = 3) &   theme(legend.position = \"bottom\")"},{"path":"/articles/minpatch-oceandatr-Seychelles.html","id":"selected-planning-units-baseline-vs-minpatch-runs-1","dir":"Articles","previous_headings":"9. Interpreting MinPatch with boundary penalties outcomes","what":"9.2 Selected planning units (baseline vs MinPatch runs)","title":"Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)","text":"check resulting spatial solutions, focusing selected planning units.  resulting plots identical.","code":"patchwork::wrap_plots(plot_prioritizr(result3$solution, col = \"minpatch\", title = paste0(\"Boundary Penalty: \", bp3)),                       plot_prioritizr(result4$solution, col = \"minpatch\", title = paste0(\"Boundary Penalty: \", bp4)),                       plot_prioritizr(result5$solution, col = \"minpatch\", title = paste0(\"Boundary Penalty: \", bp5)),                       guides = \"collect\",                       ncol = 3) &   theme(legend.position = \"bottom\")"},{"path":"/articles/minpatch-oceandatr-Seychelles.html","id":"group-summary-table-all-runs-1","dir":"Articles","previous_headings":"9. Interpreting MinPatch with boundary penalties outcomes","what":"9.3 Group summary table (all runs)","title":"Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)","text":"summarise compare runs using table. table shows increasing boundary penalty alter reported metrics example.","code":"# helper to grab one metric from the compare_solutions()$overall table get_metric <- function(overall, column, metric) {   out <- overall[[column]][overall$Metric == metric]   if (length(out) == 0) NA_real_ else out  # safer: return NA if not found }  # MinPatch results for different boundary penalties boundary_penalties <- c(bp3, bp4, bp5)  minpatch_results_bp <- list(   result3,   result4,   result5 )  # runtimes taken from your system.time() calls minpatch_runtimes <- list(   t3[[\"elapsed\"]],   t4[[\"elapsed\"]],   t5[[\"elapsed\"]] )  # baseline metrics from the first comparison (same \"Original\" across runs) overall0 <- compare_solutions(minpatch_results_bp[[1]])$overall  baseline_row <- tibble::tibble(   scenario            = \"baseline\",   boundary_penalty    = NA_real_,   selected_pu         = get_metric(overall0, \"Original\", \"Selected Planning Units\"),   total_area          = get_metric(overall0, \"Original\", \"Total Area\"),   n_patches           = get_metric(overall0, \"Original\", \"Number of Patches\"),   valid_patches       = get_metric(overall0, \"Original\", \"Valid Patches (>= min size)\"),   median_patch_size   = get_metric(overall0, \"Original\", \"Median Patch Size\"),   planning_unit_cost  = get_metric(overall0, \"Original\", \"Planning Unit Cost\"),   boundary_cost       = get_metric(overall0, \"Original\", \"Boundary Cost\"),   total_cost          = get_metric(overall0, \"Original\", \"Total Cost\"),   runtime_sec         = t_base[[\"elapsed\"]]   # baseline runtime from your code )  # metrics for each MinPatch run (different boundary penalties) minpatch_rows <- purrr::pmap_dfr(   list(     minpatch_results_bp,     as.list(boundary_penalties),     minpatch_runtimes   ),   function(res, bp, rt) {     overall <- compare_solutions(res)$overall          tibble::tibble(       scenario            = paste0(\"minpatch_bp\", bp),       boundary_penalty    = bp,       selected_pu         = get_metric(overall, \"MinPatch\", \"Selected Planning Units\"),       total_area          = get_metric(overall, \"MinPatch\", \"Total Area\"),       n_patches           = get_metric(overall, \"MinPatch\", \"Number of Patches\"),       valid_patches       = get_metric(overall, \"MinPatch\", \"Valid Patches (>= min size)\"),       median_patch_size   = get_metric(overall, \"MinPatch\", \"Median Patch Size\"),       planning_unit_cost  = get_metric(overall, \"MinPatch\", \"Planning Unit Cost\"),       boundary_cost       = get_metric(overall, \"MinPatch\", \"Boundary Cost\"),       total_cost          = get_metric(overall, \"MinPatch\", \"Total Cost\"),       runtime_sec         = rt   # runtime from t3/t4/t5     )   } )  # combine baseline + all MinPatch runs in one table solution_summary <- dplyr::bind_rows(baseline_row, minpatch_rows) solution_summary #> # A tibble: 4 × 11 #>   scenario       boundary_penalty selected_pu total_area n_patches valid_patches #>   <chr>                     <dbl>       <dbl>      <dbl>     <dbl>         <dbl> #> 1 baseline               NA               453    4.08e11       146            22 #> 2 minpatch_bp0            0               454    4.09e11        26            25 #> 3 minpatch_bp0.…          0.00001         454    4.09e11        26            25 #> 4 minpatch_bp1            1               464    4.18e11        24            23 #> # ℹ 5 more variables: median_patch_size <dbl>, planning_unit_cost <dbl>, #> #   boundary_cost <dbl>, total_cost <dbl>, runtime_sec <dbl>"},{"path":"/articles/minpatch-oceandatr-Seychelles.html","id":"individual-summaries-per-run-1","dir":"Articles","previous_headings":"9. Interpreting MinPatch with boundary penalties outcomes","what":"9.4 Individual summaries (per run)","title":"Using oceandatr and minpatch to reduce fragmentation in a marine planning region (Seychelles)","text":"show individual summaries every run detail. Similarly, values across individual summaries .","code":"library(knitr)  # MinPatch results for different boundary penalties boundary_penalties <- c(0, 1e-5, 1e-10)  minpatch_results_bp <- list(   result3,   result4,   result5 )  # Runtimes taken from system.time() calls minpatch_runtimes <- c(   t3[[\"elapsed\"]],   t4[[\"elapsed\"]],   t5[[\"elapsed\"]] )  # Loop over all MinPatch results (different boundary penalties) for (i in seq_along(minpatch_results_bp)) {    result      <- minpatch_results_bp[[i]]   bp          <- boundary_penalties[i]   runtime_sec <- minpatch_runtimes[i]    # ---- Scenario header ----   cat(     \"\\n\\n## Scenario: MinPatch with boundary penalty = \",     format(bp, scientific = TRUE),     \"\\n\\n\",     sep = \"\"   )    # ---- Runtime ----   if (!is.na(runtime_sec)) {     cat(       \"**Runtime:** \",       sprintf(\"%.2f\", runtime_sec),       \" seconds\\n\\n\",       sep = \"\"     )   }    # ---- MinPatch processing summary ----   cat(\"### MinPatch processing summary\\n\\n\")   print_minpatch_summary(result)    # ---- Compare solutions ----   comparison <- compare_solutions(result)    # ---- Overall comparison ----   cat(\"\\n### Overall solution comparison\\n\\n\")   knitr::kable(     comparison$overall,     caption = paste0(       \"Comparison between the original and MinPatch-adjusted solutions (boundary penalty = \",       format(bp, scientific = TRUE),       \")\"     )   )    # ---- Feature-level comparison ----   cat(\"\\n### Feature-level area comparison\\n\\n\")   knitr::kable(     comparison$features,     caption = paste0(       \"Feature-level area and proportional changes after MinPatch (boundary penalty = \",       format(bp, scientific = TRUE),       \")\"     )   )    # ---- Feature change summary ----   cat(\"\\n### Feature change summary\\n\\n\")   knitr::kable(     comparison$summary,     caption = paste0(       \"Summary of improved, reduced, and unchanged features (boundary penalty = \",       format(bp, scientific = TRUE),       \")\"     )   ) } #>  #>  #> ## Scenario: MinPatch with boundary penalty = 0e+00 #>  #> **Runtime:** 35.25 seconds #>  #> ### MinPatch processing summary #>  #> === MinPatch Processing Summary === #>  #> Patch Statistics: #>   Initial patches: 146 (valid: 22) #>   Final patches: 26 (valid: 25) #>   Area change: 900212583.64 (0.2%) #>  #> Cost Breakdown: #>   Planning unit cost: 408696.51 #>   Boundary cost: 0.00 #>   Total cost: 408696.51 #>   Selected units: 454 #>  #> Feature Representation: #>   Total features: 28 #>   Targets met: 28 #>   Targets unmet: 0 #>   Mean proportion: 0.399 #>   Total shortfall: 0.00 #>  #>  #> === End Summary === #>  #> ### Overall solution comparison #>  #>  #> ### Feature-level area comparison #>  #>  #> ### Feature change summary #>  #>  #>  #> ## Scenario: MinPatch with boundary penalty = 1e-05 #>  #> **Runtime:** 35.78 seconds #>  #> ### MinPatch processing summary #>  #> === MinPatch Processing Summary === #>  #> Patch Statistics: #>   Initial patches: 146 (valid: 22) #>   Final patches: 26 (valid: 25) #>   Area change: 900212583.64 (0.2%) #>  #> Cost Breakdown: #>   Planning unit cost: 408696.51 #>   Boundary cost: 173.17 #>   Total cost: 408869.69 #>   Selected units: 454 #>  #> Feature Representation: #>   Total features: 28 #>   Targets met: 28 #>   Targets unmet: 0 #>   Mean proportion: 0.399 #>   Total shortfall: 0.00 #>  #>  #> === End Summary === #>  #> ### Overall solution comparison #>  #>  #> ### Feature-level area comparison #>  #>  #> ### Feature change summary #>  #>  #>  #> ## Scenario: MinPatch with boundary penalty = 1e-10 #>  #> **Runtime:** 50.86 seconds #>  #> ### MinPatch processing summary #>  #> === MinPatch Processing Summary === #>  #> Patch Statistics: #>   Initial patches: 146 (valid: 22) #>   Final patches: 24 (valid: 23) #>   Area change: 9902338420.10 (2.4%) #>  #> Cost Breakdown: #>   Planning unit cost: 417698.64 #>   Boundary cost: 17197209.33 #>   Total cost: 17614907.97 #>   Selected units: 464 #>  #> Feature Representation: #>   Total features: 28 #>   Targets met: 28 #>   Targets unmet: 0 #>   Mean proportion: 0.416 #>   Total shortfall: 0.00 #>  #>  #> === End Summary === #>  #> ### Overall solution comparison #>  #>  #> ### Feature-level area comparison #>  #>  #> ### Feature change summary"},{"path":"/articles/minpatch.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"MinPatch with prioritizr","text":"vignette demonstrates use MinPatch real conservation planning data prioritizr. ’ll use simulated dataset included prioritizr show complete workflow problem formulation MinPatch post-processing.","code":"library(minpatch) library(prioritizr) library(sf) library(terra) library(dplyr) library(ggplot2) library(patchwork)"},{"path":"/articles/minpatch.html","id":"step-1-load-and-examine-the-data","dir":"Articles","previous_headings":"Introduction","what":"Step 1: Load and Examine the Data","title":"MinPatch with prioritizr","text":"","code":"dat <- c(get_sim_pu_raster(), get_sim_features()) %>%    as.polygons(dissolve = FALSE, values = TRUE) %>%   sf::st_as_sf() %>%    dplyr::rename(cost = layer)  st_crs(dat) <- NA  features = colnames(dat) %>%    stringr::str_subset(\"feature_\")"},{"path":"/articles/minpatch.html","id":"step-2-create-and-solve-a-prioritizr-problem","dir":"Articles","previous_headings":"Introduction","what":"Step 2: Create and Solve a prioritizr Problem","title":"MinPatch with prioritizr","text":"’ll create simple minimum set problem 17% targets features:","code":"# Create prioritizr problem p <- problem(dat, features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.17) %>%  # 17% of each feature   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # Solve the problem s <- solve(p) # plot map of prioritization plot_prioritizr(s)"},{"path":"/articles/minpatch.html","id":"step-3-run-minpatch","dir":"Articles","previous_headings":"Introduction","what":"Step 3: Run MinPatch","title":"MinPatch with prioritizr","text":"Now can apply MinPatch directly prioritizr objects. run_minpatch() function automatically extracts necessary data prioritizr solution object: Run MinPatch automatic data extraction prioritizr objects","code":"# Calculate reasonable parameters based on planning unit characteristics median_area <- median(st_area(dat))  # Set minimum patch size to 5x median planning unit area min_patch_size <- median_area * 5  # Set patch radius to encompass approximately 10 planning units patch_radius <- sqrt(median_area * 10)  cat(\"MinPatch parameters:\\n\") #> MinPatch parameters: cat(\"- Minimum patch size:\", round(min_patch_size, 3), \"square meters\\n\") #> - Minimum patch size: 0.05 square meters cat(\"- Patch radius:\", round(patch_radius,3), \"meters\\n\") #> - Patch radius: 0.316 meters cat(\"- This means patches must be at least\", round(min_patch_size/median_area, 3),     \"times the median planning unit size\\n\") #> - This means patches must be at least 5 times the median planning unit size result <- run_minpatch(   prioritizr_problem = p,   prioritizr_solution = s,   min_patch_size = min_patch_size,   patch_radius = patch_radius,   boundary_penalty = 0.001,  # Small boundary penalty for connectivity   remove_small_patches = TRUE,   add_patches = TRUE,   whittle_patches = TRUE,   verbose = TRUE ) #> Validating inputs... #> Initializing data structures... #> Calculating boundary matrix (optimized version)... #> Creating patch radius dictionary (optimized)... #> Calculating initial patch statistics... #> Stage 1: Removing small patches... #> Stage 2: Adding new patches... #>   Initial unmet targets: 5  #>   Unmet feature IDs: 1, 2, 3, 4, 5  #>   Iteration 1 - Unmet targets: 5  #>     Found 90 potential patches with scores #>     Best score: 0.001650111 for unit 89  #>     Added patch centered on unit 89  #>   Iteration 2 - Unmet targets: 5  #>     Found 78 potential patches with scores #>     Best score: 0.001677852 for unit 86  #>     Added patch centered on unit 86  #>   All conservation targets are now met! #> Stage 3: Removing unnecessary planning units... #>     Edge units found: 5  #>     Keystone units: 0  #>     New keystone units: 0  #>     Scoreable units: 5  #>     Unit 61 cannot be removed - adding to keystone set #>     Edge units found: 4  #>     Keystone units: 1  #>     New keystone units: 0  #>     Scoreable units: 4  #>     Unit 62 cannot be removed - adding to keystone set #>     Edge units found: 3  #>     Keystone units: 2  #>     New keystone units: 0  #>     Scoreable units: 3  #>     Unit 66 cannot be removed - adding to keystone set #>     Edge units found: 2  #>     Keystone units: 3  #>     New keystone units: 0  #>     Scoreable units: 2  #>     Unit 64 cannot be removed - adding to keystone set #>     Edge units found: 1  #>     Keystone units: 4  #>     New keystone units: 0  #>     Scoreable units: 1  #>     Unit 65 cannot be removed - adding to keystone set #>   No more edge units to consider - terminating #> Calculating final statistics... #> MinPatch processing complete!"},{"path":"/articles/minpatch.html","id":"step-4-analyze-the-results","dir":"Articles","previous_headings":"Introduction","what":"Step 4: Analyze the Results","title":"MinPatch with prioritizr","text":"Let’s examine MinPatch accomplished:","code":"# Print comprehensive summary print_minpatch_summary(result) #> === MinPatch Processing Summary === #>  #> Patch Statistics: #>   Initial patches: 9 (valid: 0) #>   Final patches: 9 (valid: 0) #>   Area change: 0.10 (62.5%) #>  #> Cost Breakdown: #>   Planning unit cost: 5150.73 #>   Boundary cost: 0.00 #>   Total cost: 5150.74 #>   Selected units: 26 #>  #> Feature Representation: #>   Total features: 5 #>   Targets met: 5 #>   Targets unmet: 0 #>   Mean proportion: 0.292 #>   Total shortfall: 0.00 #>  #>  #> === End Summary ===  # Compare original vs MinPatch solutions comparison <- compare_solutions(result)  # Print overall comparison cat(\"=== Overall Solution Comparison ===\\n\") #> === Overall Solution Comparison === print(comparison$overall) #>                        Metric   Original   MinPatch Change Percent_Change #> 1     Selected Planning Units   16.00000   26.00000  10.00           62.5 #> 2                  Total Area    0.16000    0.26000   0.10           62.5 #> 3           Number of Patches    9.00000    9.00000   0.00            0.0 #> 4 Valid Patches (>= min size)    0.00000    0.00000   0.00             NA #> 5           Median Patch Size    0.01000    0.03000   0.02          200.0 #> 6          Planning Unit Cost 5150.73485 5150.73485   0.00            0.0 #> 7               Boundary Cost    0.00365    0.00365   0.00            0.0 #> 8                  Total Cost 5150.73850 5150.73850   0.00            0.0  # Print feature-level comparison cat(\"\\n=== Feature-Level Area Comparison ===\\n\") #>  #> === Feature-Level Area Comparison === print(comparison$features) #>   Feature_ID    Target Original_Area MinPatch_Area Area_Change Percent_Change #> 1          1 12.670220     14.083429     23.172903    9.089474       64.54020 #> 2          2  4.774965      5.124808      7.472416    2.347608       45.80870 #> 3          3 11.029225     11.707674     18.831232    7.123557       60.84520 #> 4          4  6.489033      6.863962     10.491540    3.627578       52.84963 #> 5          5  8.613574      9.482534     16.114067    6.631533       69.93419 #>   Original_Target_Met MinPatch_Target_Met Original_Proportion #> 1                TRUE                TRUE            1.111538 #> 2                TRUE                TRUE            1.073266 #> 3                TRUE                TRUE            1.061514 #> 4                TRUE                TRUE            1.057779 #> 5                TRUE                TRUE            1.100883 #>   MinPatch_Proportion #> 1            1.828927 #> 2            1.564915 #> 3            1.707394 #> 4            1.616811 #> 5            1.870776  # Print summary statistics cat(\"\\n=== Feature Change Summary ===\\n\") #>  #> === Feature Change Summary === print(comparison$summary) #>   features_improved features_reduced features_unchanged targets_gained #> 1                 5                0                  0              0 #>   targets_lost #> 1            0  # cat(\"Features with increased area:\", comparison$summary$features_improved, \"\\n\") # cat(\"Features with decreased area:\", comparison$summary$features_reduced, \"\\n\") # cat(\"Features with unchanged area:\", comparison$summary$features_unchanged, \"\\n\") # cat(\"Targets gained:\", comparison$summary$targets_gained, \"\\n\") # cat(\"Targets lost:\", comparison$summary$targets_lost, \"\\n\")"},{"path":"/articles/minpatch.html","id":"feature-representation-analysis","dir":"Articles","previous_headings":"Introduction > Step 4: Analyze the Results","what":"Feature Representation Analysis","title":"MinPatch with prioritizr","text":"","code":"# Create solution data for prioritizr analysis minpatch_solution_data <- result$solution[c(\"minpatch\")]  # Use prioritizr functions for accurate feature representation analysis feature_rep <- prioritizr::eval_feature_representation_summary(p, minpatch_solution_data) target_coverage <- prioritizr::eval_target_coverage_summary(p, minpatch_solution_data)  # Summary statistics targets_met <- sum(target_coverage$met) mean_achievement <- mean(feature_rep$relative_held, na.rm = TRUE)  cat(\"Conservation Performance:\\n\") #> Conservation Performance: cat(\"- Targets met:\", targets_met, \"out of\", nrow(feature_rep), \"features\\n\") #> - Targets met: 5 out of 5 features cat(\"- Mean target achievement:\", round(mean_achievement * 100, 1), \"%\\n\") #> - Mean target achievement: 29.2 %  # Show features with lowest achievement combined_results <- data.frame(   feature_id = seq_len(nrow(feature_rep)),   proportion_met = feature_rep$relative_held,   target_met = target_coverage$met )  worst_features <- combined_results[order(combined_results$proportion_met), ][1:5, ]  cat(\"\\nFeatures with lowest target achievement:\\n\") #>  #> Features with lowest target achievement: print(worst_features) #>   feature_id proportion_met target_met #> 2          2      0.2660356       TRUE #> 4          4      0.2748579       TRUE #> 3          3      0.2902570       TRUE #> 1          1      0.3109175       TRUE #> 5          5      0.3180319       TRUE"},{"path":"/articles/minpatch.html","id":"spatial-configuration-improvements","dir":"Articles","previous_headings":"Introduction > Step 4: Analyze the Results","what":"Spatial Configuration Improvements","title":"MinPatch with prioritizr","text":"","code":"initial_stats <- result$patch_stats$initial final_stats <- result$patch_stats$final  cat(\"Spatial Configuration Changes:\\n\") #> Spatial Configuration Changes: cat(\"- Initial patches:\", initial_stats$all_patch_count,      \"(\", initial_stats$valid_patch_count, \"valid)\\n\") #> - Initial patches: 9 ( 0 valid) cat(\"- Final patches:\", final_stats$all_patch_count,      \"(\", final_stats$valid_patch_count, \"valid)\\n\") #> - Final patches: 9 ( 0 valid) cat(\"- Patch consolidation:\",      round((1 - final_stats$all_patch_count/initial_stats$all_patch_count) * 100, 1),      \"% reduction\\n\") #> - Patch consolidation: 0 % reduction cat(\"- Median patch size increase:\",      round(final_stats$median_all_patch / initial_stats$median_all_patch, 1), \"x\\n\") #> - Median patch size increase: 3 x"},{"path":"/articles/minpatch.html","id":"step-5-visualize-the-results","dir":"Articles","previous_headings":"Introduction","what":"Step 5: Visualize the Results","title":"MinPatch with prioritizr","text":"Let’s create maps visualize changes MinPatch made:","code":"plot_minpatch(result, title = \"MinPatch Results\")"},{"path":"/articles/minpatch.html","id":"working-with-locked-constraints","dir":"Articles","previous_headings":"Introduction","what":"Working with Locked Constraints","title":"MinPatch with prioritizr","text":"MinPatch automatically respects locked-locked-constraints prioritizr. useful certain areas must included (e.g., existing reserves) excluded (e.g., areas conflicting uses).","code":""},{"path":"/articles/minpatch.html","id":"example-adding-locked-in-constraints","dir":"Articles","previous_headings":"Introduction > Working with Locked Constraints","what":"Example: Adding Locked-In Constraints","title":"MinPatch with prioritizr","text":"Let’s designate existing planning units locked-(must conserved):","code":"# Select some units as existing protected areas (locked-in) locked_in_units <- c(10, 11, 20, 21, 30, 31)  # Create problem with locked-in constraints p_locked_in <- problem(dat, features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.17) %>%   add_locked_in_constraints(locked_in_units) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # Solve and apply MinPatch s_locked_in <- solve(p_locked_in)  result_locked_in <- run_minpatch(   prioritizr_problem = p_locked_in,   prioritizr_solution = s_locked_in,   min_patch_size = min_patch_size,   patch_radius = patch_radius,   boundary_penalty = 0.001,   verbose = FALSE )  # Verify locked-in units are preserved cat(\"Locked-in units in final solution:\\n\") #> Locked-in units in final solution: cat(\"Units:\", locked_in_units, \"\\n\") #> Units: 10 11 20 21 30 31 cat(\"Status in solution:\", result_locked_in$solution$minpatch[locked_in_units], \"\\n\") #> Status in solution: 1 1 1 1 1 1 cat(\"All locked-in units preserved:\",     all(result_locked_in$solution$minpatch[locked_in_units] == 1), \"\\n\") #> All locked-in units preserved: TRUE"},{"path":"/articles/minpatch.html","id":"example-adding-locked-out-constraints","dir":"Articles","previous_headings":"Introduction > Working with Locked Constraints","what":"Example: Adding Locked-Out Constraints","title":"MinPatch with prioritizr","text":"Now let’s exclude certain areas selection (e.g., areas conflicting land uses):","code":"# Select some units to exclude (locked-out) locked_out_units <- c(50, 51, 60, 61, 70, 71)  # Create problem with locked-out constraints p_locked_out <- problem(dat, features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.17) %>%   add_locked_out_constraints(locked_out_units) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # Solve and apply MinPatch s_locked_out <- solve(p_locked_out)  result_locked_out <- run_minpatch(   prioritizr_problem = p_locked_out,   prioritizr_solution = s_locked_out,   min_patch_size = min_patch_size,   patch_radius = patch_radius,   boundary_penalty = 0.001,   verbose = FALSE )  # Verify locked-out units are excluded cat(\"Locked-out units in final solution:\\n\") #> Locked-out units in final solution: cat(\"Units:\", locked_out_units, \"\\n\") #> Units: 50 51 60 61 70 71 cat(\"Status in solution:\", result_locked_out$solution$minpatch[locked_out_units], \"\\n\") #> Status in solution: 0 0 0 0 0 0 cat(\"All locked-out units excluded:\",     all(result_locked_out$solution$minpatch[locked_out_units] == 0), \"\\n\") #> All locked-out units excluded: TRUE"},{"path":"/articles/minpatch.html","id":"example-combining-both-constraint-types","dir":"Articles","previous_headings":"Introduction > Working with Locked Constraints","what":"Example: Combining Both Constraint Types","title":"MinPatch with prioritizr","text":"can use locked-locked-constraints together:","code":"# Create problem with both constraint types p_locked_both <- problem(dat, features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.17) %>%   add_locked_in_constraints(locked_in_units) %>%   add_locked_out_constraints(locked_out_units) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # Solve and apply MinPatch s_locked_both <- solve(p_locked_both)  result_locked_both <- run_minpatch(   prioritizr_problem = p_locked_both,   prioritizr_solution = s_locked_both,   min_patch_size = min_patch_size,   patch_radius = patch_radius,   boundary_penalty = 0.001,   verbose = FALSE )  cat(\"Constraint Summary:\\n\") #> Constraint Summary: cat(\"- Locked-in units preserved:\",     all(result_locked_both$solution$minpatch[locked_in_units] == 1), \"\\n\") #> - Locked-in units preserved: TRUE cat(\"- Locked-out units excluded:\",     all(result_locked_both$solution$minpatch[locked_out_units] == 0), \"\\n\") #> - Locked-out units excluded: TRUE"},{"path":"/articles/minpatch.html","id":"key-points-about-locked-constraints","dir":"Articles","previous_headings":"Introduction > Working with Locked Constraints","what":"Key Points About Locked Constraints","title":"MinPatch with prioritizr","text":"Locked-units never removed: Even form patches smaller min_patch_size, locked-units preserved three stages MinPatch. Locked-units never selected: Stage 2 (patch addition), locked-units considered even help meet conservation targets. Automatic detection: MinPatch automatically extracts applies locked constraints prioritizr problem—additional parameters needed! Warnings small locked-patches: locked-units form patches smaller min_patch_size, MinPatch issue warning still preserve units.","code":""},{"path":[]},{"path":"/articles/minpatch.html","id":"lets-check-the-process","dir":"Articles","previous_headings":"Introduction > Understanding the Results","what":"Lets check the process","title":"MinPatch with prioritizr","text":"Plot comparison","code":"# First remove small patches result_remove <- run_minpatch(   prioritizr_problem = p,   prioritizr_solution = s,   min_patch_size = min_patch_size,   patch_radius = patch_radius,   remove_small_patches = TRUE,   add_patches = FALSE,   whittle_patches = FALSE,   verbose = FALSE ) #> Warning in run_minpatch(prioritizr_problem = p, prioritizr_solution = s, : #> After removing small patches, 5 conservation targets are no longer met. #> Consider setting add_patches = TRUE to automatically add patches to meet #> targets, or use a smaller min_patch_size.  # Next add to ensure patches meet minimum size result_add <- run_minpatch(   prioritizr_problem = p,   prioritizr_solution = s,   min_patch_size = min_patch_size,   patch_radius = patch_radius,   remove_small_patches = TRUE,   add_patches = TRUE,   whittle_patches = FALSE,   verbose = FALSE )  # Finally, try and remove areas without degrading the solution result_whittle <- run_minpatch(   prioritizr_problem = p,   prioritizr_solution = s,   min_patch_size = min_patch_size,   patch_radius = patch_radius,   remove_small_patches = TRUE,   add_patches = TRUE,   whittle_patches = TRUE,   verbose = FALSE ) patchwork::wrap_plots(   plot_minpatch(result_remove, title = \"Remove Small Patches\"),   plot_minpatch(result_add, title = \"Add Patches\"),   plot_minpatch(result_whittle, title = \"Whittle Planning Units\"),    guides = \"collect\",   ncol = 3 ) & theme(legend.position = \"bottom\")"},{"path":"/articles/minpatch.html","id":"what-minpatch-accomplished","dir":"Articles","previous_headings":"Introduction > Understanding the Results","what":"What MinPatch Accomplished","title":"MinPatch with prioritizr","text":"Patch Consolidation: MinPatch reduced number patches removing small, inefficient patches consolidating remaining areas larger, viable patches. Size Constraint Satisfaction: final patches now meet minimum size threshold, ensuring large enough ecologically viable cost-effective manage. Target Achievement: Conservation targets maintained improved, demonstrating MinPatch doesn’t compromise conservation effectiveness. Cost Optimization: boundary penalty helps create compact patches, potentially reducing management costs.","code":""},{"path":"/articles/minpatch.html","id":"key-insights","dir":"Articles","previous_headings":"Introduction > Understanding the Results","what":"Key Insights","title":"MinPatch with prioritizr","text":"Efficiency vs. Viability Trade-: original prioritizr solution mathematically optimal contained many small patches. MinPatch trades mathematical optimality practical viability. Context-Dependent Parameters: choice minimum patch size patch radius based ecological requirements, management constraints, expert knowledge. Computational Considerations: Processing time scales number planning units complexity spatial configuration.","code":""},{"path":[]},{"path":"/articles/minpatch.html","id":"parameter-selection","dir":"Articles","previous_headings":"Introduction > Best Practices","what":"Parameter Selection","title":"MinPatch with prioritizr","text":"Ecological requirements (home range sizes, minimum viable populations) Management efficiency (minimum economically viable management units) Expert knowledge study system Large enough allow elongated patches large create unnecessarily large patches Based typical dispersal distances management scales Connectivity patches important Compact patches preferred management Edge effects concern","code":""},{"path":"/articles/minpatch.html","id":"validation","dir":"Articles","previous_headings":"Introduction > Best Practices","what":"Validation","title":"MinPatch with prioritizr","text":"Always validate results : Checking target achievement: Ensure conservation goals still met Examining spatial patterns: Verify patches make ecological sense Comparing costs: Understand trade-offs involved Expert review: domain experts review final configuration","code":""},{"path":[]},{"path":"/articles/minpatch.html","id":"multiple-scenarios","dir":"Articles","previous_headings":"Introduction > Advanced Usage","what":"Multiple Scenarios","title":"MinPatch with prioritizr","text":"can run MinPatch different parameters explore trade-offs:","code":"# Conservative scenario (larger patches) result_conservative <- run_minpatch(   prioritizr_problem = p,   prioritizr_solution = s,   min_patch_size = median_area * 10,  # Larger minimum size   patch_radius = patch_radius * 1.5,   boundary_penalty = 0.01,  # Higher boundary penalty   verbose = FALSE )  # Compare scenarios compare_solutions(result_conservative) #> $overall #>                        Metric  Original  MinPatch Change Percent_Change #> 1     Selected Planning Units   16.0000   18.0000  2.000       12.50000 #> 2                  Total Area    0.1600    0.1800  0.020       12.50000 #> 3           Number of Patches    9.0000    4.0000 -5.000      -55.55556 #> 4 Valid Patches (>= min size)    0.0000    0.0000  0.000             NA #> 5           Median Patch Size    0.0100    0.0450  0.035      350.00000 #> 6          Planning Unit Cost 3535.2989 3535.2989  0.000        0.00000 #> 7               Boundary Cost    0.0225    0.0225  0.000        0.00000 #> 8                  Total Cost 3535.3214 3535.3214  0.000        0.00000 #>  #> $features #>   Feature_ID    Target Original_Area MinPatch_Area Area_Change Percent_Change #> 1          1 12.670220     14.083429     15.583069   1.4996396      10.648256 #> 2          2  4.774965      5.124808      4.827211  -0.2975976      -5.807000 #> 3          3 11.029225     11.707674     12.033291   0.3256171       2.781228 #> 4          4  6.489033      6.863962      8.002595   1.1386334      16.588574 #> 5          5  8.613574      9.482534     11.419918   1.9373846      20.431086 #>   Original_Target_Met MinPatch_Target_Met Original_Proportion #> 1                TRUE                TRUE            1.111538 #> 2                TRUE                TRUE            1.073266 #> 3                TRUE                TRUE            1.061514 #> 4                TRUE                TRUE            1.057779 #> 5                TRUE                TRUE            1.100883 #>   MinPatch_Proportion #> 1            1.229897 #> 2            1.010942 #> 3            1.091037 #> 4            1.233249 #> 5            1.325805 #>  #> $summary #>   features_improved features_reduced features_unchanged targets_gained #> 1                 4                1                  0              0 #>   targets_lost #> 1            0"},{"path":"/articles/minpatch.html","id":"conclusion","dir":"Articles","previous_headings":"Introduction","what":"Conclusion","title":"MinPatch with prioritizr","text":"MinPatch provides powerful way post-process prioritizr solutions ensure meet minimum patch size requirements maintaining conservation effectiveness. Tasmania case study demonstrates MinPatch can successfully: Handle real-world conservation planning datasets Consolidate fragmented solutions viable patch configurations Maintain improve conservation target achievement Provide transparent reporting trade-offs improvements integrating MinPatch conservation planning workflow, can bridge gap mathematically optimal solutions practically implementable conservation strategies.","code":""},{"path":"/articles/minpatch.html","id":"session-information","dir":"Articles","previous_headings":"Introduction","what":"Session Information","title":"MinPatch with prioritizr","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: aarch64-apple-darwin20 #> Running under: macOS Tahoe 26.3 #>  #> Matrix products: default #> BLAS:   /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib  #> LAPACK: /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.1 #>  #> locale: #> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 #>  #> time zone: Australia/Sydney #> tzcode source: internal #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] patchwork_1.3.2  ggplot2_4.0.2    dplyr_1.2.0      terra_1.8-93     #> [5] sf_1.0-24        prioritizr_8.1.0 minpatch_0.1.0   #>  #> loaded via a namespace (and not attached): #>  [1] gtable_0.3.6         xfun_0.56            bslib_0.10.0         #>  [4] raster_3.6-32        htmlwidgets_1.6.4    lattice_0.22-9       #>  [7] vctrs_0.7.1          tools_4.5.2          generics_0.1.4       #> [10] parallel_4.5.2       tibble_3.3.1         proxy_0.4-29         #> [13] pkgconfig_2.0.3      Matrix_1.7-4         KernSmooth_2.23-26   #> [16] RColorBrewer_1.1-3   S7_0.2.1             desc_1.4.3           #> [19] assertthat_0.2.1     lifecycle_1.0.5      compiler_4.5.2       #> [22] farver_2.1.2         stringr_1.6.0        textshaping_1.0.4    #> [25] codetools_0.2-20     htmltools_0.5.9      class_7.3-23         #> [28] sass_0.4.10          yaml_2.3.12          pillar_1.11.1        #> [31] pkgdown_2.2.0        exactextractr_0.10.1 jquerylib_0.1.4      #> [34] rcbc_0.1.0.9003      classInt_0.4-11      cachem_1.1.0         #> [37] nlme_3.1-168         parallelly_1.46.1    tidyselect_1.2.1     #> [40] digest_0.6.39        stringi_1.8.7        fastmap_1.2.0        #> [43] grid_4.5.2           cli_3.6.5            magrittr_2.0.4       #> [46] e1071_1.7-17         ape_5.8-1            withr_3.0.2          #> [49] scales_1.4.0         sp_2.2-1             rmarkdown_2.30       #> [52] igraph_2.2.2         otel_0.2.0           ragg_1.5.0           #> [55] evaluate_1.0.5       knitr_1.51           rlang_1.1.7          #> [58] Rcpp_1.1.1           glue_1.8.0           DBI_1.2.3            #> [61] rstudioapi_0.18.0    jsonlite_2.0.0       R6_2.6.1             #> [64] systemfonts_1.3.1    fs_1.6.6             units_1.0-0"},{"path":"/articles/minpatchTasmania.html","id":"load-packages","dir":"Articles","previous_headings":"","what":"Load packages","title":"MinPatch in Tasmania","text":"","code":"library(minpatch) library(prioritizr) library(prioritizrdata) library(terra) library(sf) library(ggplot2) library(dplyr)"},{"path":"/articles/minpatchTasmania.html","id":"load-data","dir":"Articles","previous_headings":"","what":"Load data","title":"MinPatch in Tasmania","text":"","code":"# load data tas_pu <- get_tas_pu() %>%    mutate(cost = cost*10000)  # At present minpatch works with sf objects. Here we convert the data to sf. tas_features <- get_tas_features() %>%    stars::st_as_stars() %>%    sf::st_as_sf()  tas <- sf::st_interpolate_aw(tas_features, tas_pu, extensive = FALSE, keep_NA = FALSE, na.rm = FALSE) %>%    st_join(tas_pu, join = st_equals) #> Warning in st_interpolate_aw.sf(tas_features, tas_pu, extensive = FALSE, : #> st_interpolate_aw assumes attributes are constant or uniform over areas of x   features = tas %>%    sf::st_drop_geometry() %>%    dplyr::select(-all_of(c(\"id\", \"cost\", \"locked_in\", \"locked_out\"))) %>%    names()  # Convert data to binary again tas <- tas %>%    mutate(across(all_of(features), ~ if_else(.x > 0, 1, 0)))"},{"path":"/articles/minpatchTasmania.html","id":"run-prioritizr-analysis","dir":"Articles","previous_headings":"","what":"Run prioritizr analysis","title":"MinPatch in Tasmania","text":"","code":"p <- problem(tas, features = features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.30) %>%  # 30% of each feature   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  s <- solve(p)"},{"path":"/articles/minpatchTasmania.html","id":"plot-prioritizr-solution","dir":"Articles","previous_headings":"Run prioritizr analysis","what":"Plot prioritizr solution","title":"MinPatch in Tasmania","text":"","code":"plot_prioritizr(s)"},{"path":[]},{"path":"/articles/minpatchTasmania.html","id":"choose-a-patch-size","dir":"Articles","previous_headings":"MinPatch","what":"Choose a patch size","title":"MinPatch in Tasmania","text":"","code":"# Calculate reasonable parameters based on planning unit characteristics median_area <- median(st_area(tas))  # Set minimum patch size to 5x median planning unit area min_patch_size <- median_area * 5  # Set patch radius to encompass approximately 10 planning units patch_radius <- sqrt(median_area * 10)  cat(\"MinPatch parameters:\\n\") #> MinPatch parameters: cat(\"- Minimum patch size:\", round(min_patch_size, 3), \"square meters\\n\") #> - Minimum patch size: 324514429 square meters cat(\"- Patch radius:\", round(patch_radius,3), \"meters\\n\") #> - Patch radius: 25476.04 meters cat(\"- This means patches must be at least\", round(min_patch_size/median_area, 3),     \"times the median planning unit size\\n\") #> - This means patches must be at least 5 times the median planning unit size"},{"path":"/articles/minpatchTasmania.html","id":"run-minpatch","dir":"Articles","previous_headings":"MinPatch","what":"Run minpatch","title":"MinPatch in Tasmania","text":"","code":"result <- run_minpatch(   prioritizr_problem = p,   prioritizr_solution = s,   min_patch_size = min_patch_size,   patch_radius = patch_radius,   remove_small_patches = TRUE,   add_patches = TRUE,   whittle_patches = TRUE,   verbose = TRUE ) #> Validating inputs... #> Initializing data structures... #> Calculating boundary matrix using 14 cores... #> Processing chunks in parallel... #> Combining results... #> Creating patch radius dictionary (optimized)... #> Processed 100 of 1128 planning units #> Processed 200 of 1128 planning units #> Processed 300 of 1128 planning units #> Processed 400 of 1128 planning units #> Processed 500 of 1128 planning units #> Processed 600 of 1128 planning units #> Processed 700 of 1128 planning units #> Processed 800 of 1128 planning units #> Processed 900 of 1128 planning units #> Processed 1000 of 1128 planning units #> Processed 1100 of 1128 planning units #> Calculating initial patch statistics... #> Stage 1: Removing small patches... #> Stage 2: Adding new patches... #>   Initial unmet targets: 30  #>   Unmet feature IDs: 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 16, 18, 19, 20, 21, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33  #>   Iteration 1 - Unmet targets: 30  #>     Found 875 potential patches with scores #>     Best score: 1.440508e-05 for unit 79  #>     Added patch centered on unit 79  #>   Iteration 2 - Unmet targets: 29  #>     Found 873 potential patches with scores #>     Best score: 7.880797e-06 for unit 421  #>     Added patch centered on unit 421  #>   Iteration 3 - Unmet targets: 27  #>     Found 864 potential patches with scores #>     Best score: 5.751114e-06 for unit 387  #>     Added patch centered on unit 387  #>   Iteration 4 - Unmet targets: 26  #>     Found 859 potential patches with scores #>     Best score: 4.461179e-06 for unit 362  #>     Added patch centered on unit 362  #>   Iteration 5 - Unmet targets: 23  #>     Found 850 potential patches with scores #>     Best score: 3.090659e-06 for unit 246  #>     Added patch centered on unit 246  #>   Iteration 10 - Unmet targets: 17  #>   All conservation targets are now met! #> Stage 3: Removing unnecessary planning units... #>     Edge units found: 154  #>     Keystone units: 0  #>     New keystone units: 9  #>     Scoreable units: 145  #>     Removed unit 438 at iteration 1  #>     Edge units found: 145  #>     Keystone units: 9  #>     New keystone units: 0  #>     Scoreable units: 145  #>     Removed unit 419 at iteration 2  #>     Edge units found: 146  #>     Keystone units: 9  #>     New keystone units: 0  #>     Scoreable units: 146  #>     Unit 439 cannot be removed - adding to keystone set #>     Edge units found: 145  #>     Keystone units: 10  #>     New keystone units: 0  #>     Scoreable units: 145  #>     Removed unit 111 at iteration 4  #>     Edge units found: 144  #>     Keystone units: 10  #>     New keystone units: 0  #>     Scoreable units: 144  #>     Removed unit 401 at iteration 5  #>     Removed unit 420 at iteration 6  #>     Removed unit 400 at iteration 7  #>     Removed unit 213 at iteration 8  #>     Removed unit 255 at iteration 9  #>     Removed unit 75 at iteration 10  #>   Whittling iteration 100  #>   No units can be removed - all are keystone - terminating #> Calculating final statistics... #> MinPatch processing complete!"},{"path":"/articles/minpatchTasmania.html","id":"visualise-the-minpatch-solution","dir":"Articles","previous_headings":"MinPatch","what":"Visualise the minpatch solution","title":"MinPatch in Tasmania","text":"","code":"plot_minpatch(result, title = \"MinPatch Results\")"},{"path":"/articles/minpatchTasmania.html","id":"analyse-the-final-results","dir":"Articles","previous_headings":"MinPatch","what":"Analyse the final results","title":"MinPatch in Tasmania","text":"","code":"print_minpatch_summary(result) #> === MinPatch Processing Summary === #>  #> Patch Statistics: #>   Initial patches: 58 (valid: 11) #>   Final patches: 15 (valid: 14) #>   Area change: -646956349.29 (-3.2%) #>  #> Cost Breakdown: #>   Planning unit cost: 59188469.96 #>   Boundary cost: 0.00 #>   Total cost: 59188469.96 #>   Selected units: 344 #>  #> Feature Representation: #>   Total features: 33 #>   Targets met: 33 #>   Targets unmet: 0 #>   Mean proportion: 0.392 #>   Total shortfall: 0.00 #>  #>  #> === End Summary ===  # Compare original vs MinPatch solutions comparison <- compare_solutions(result)  # Print overall comparison cat(\"=== Overall Solution Comparison ===\\n\") #> === Overall Solution Comparison === print(comparison$overall) #>                        Metric    Original    MinPatch     Change Percent_Change #> 1     Selected Planning Units         330         344         14       4.242424 #> 2                  Total Area 20052333083 19405376734 -646956349      -3.226340 #> 3           Number of Patches          58          15        -43     -74.137931 #> 4 Valid Patches (>= min size)          11          14          3      27.272727 #> 5           Median Patch Size    64915437   373340097  308424660     475.117591 #> 6          Planning Unit Cost    59188470    59188470          0       0.000000 #> 7               Boundary Cost           0           0          0             NA #> 8                  Total Cost    59188470    59188470          0       0.000000  # Print feature-level comparison cat(\"\\n=== Feature-Level Area Comparison ===\\n\") #>  #> === Feature-Level Area Comparison === print(comparison$features) #>    Feature_ID Target Original_Area MinPatch_Area Area_Change Percent_Change #> 1           1    1.2             2             3           1     50.0000000 #> 2           2   33.0            35            38           3      8.5714286 #> 3           3    2.7             3             5           2     66.6666667 #> 4           4  170.1           177           173          -4     -2.2598870 #> 5           5  213.9           221           214          -7     -3.1674208 #> 6           6  242.1           250           250           0      0.0000000 #> 7           7    9.9            12            11          -1     -8.3333333 #> 8           8  108.3           113           110          -3     -2.6548673 #> 9           9   30.9            41            49           8     19.5121951 #> 10         10  260.4           271           281          10      3.6900369 #> 11         11   62.4            67            66          -1     -1.4925373 #> 12         12  132.0           151           152           1      0.6622517 #> 13         13  133.5           138           134          -4     -2.8985507 #> 14         14  122.4           128           123          -5     -3.9062500 #> 15         15   62.4            66            69           3      4.5454545 #> 16         16  240.0           246           257          11      4.4715447 #> 17         17    0.3             1             1           0      0.0000000 #> 18         18   27.6            29            28          -1     -3.4482759 #> 19         19    6.6             8             8           0      0.0000000 #> 20         20   18.0            19            24           5     26.3157895 #> 21         21   24.3            31            37           6     19.3548387 #> 22         22    7.5            12            11          -1     -8.3333333 #> 23         23   34.5            39            40           1      2.5641026 #> 24         24   11.1            12            12           0      0.0000000 #> 25         25   47.1            51            71          20     39.2156863 #> 26         26    9.3            11            11           0      0.0000000 #> 27         27   86.7            88            87          -1     -1.1363636 #> 28         28    6.6             7            10           3     42.8571429 #> 29         29    1.2             2             2           0      0.0000000 #> 30         30  186.0           192           187          -5     -2.6041667 #> 31         31   66.3            71            78           7      9.8591549 #> 32         32   30.9            36            37           1      2.7777778 #> 33         33   57.9            60            58          -2     -3.3333333 #>    Original_Target_Met MinPatch_Target_Met Original_Proportion #> 1                 TRUE                TRUE            1.666667 #> 2                 TRUE                TRUE            1.060606 #> 3                 TRUE                TRUE            1.111111 #> 4                 TRUE                TRUE            1.040564 #> 5                 TRUE                TRUE            1.033193 #> 6                 TRUE                TRUE            1.032631 #> 7                 TRUE                TRUE            1.212121 #> 8                 TRUE                TRUE            1.043398 #> 9                 TRUE                TRUE            1.326861 #> 10                TRUE                TRUE            1.040707 #> 11                TRUE                TRUE            1.073718 #> 12                TRUE                TRUE            1.143939 #> 13                TRUE                TRUE            1.033708 #> 14                TRUE                TRUE            1.045752 #> 15                TRUE                TRUE            1.057692 #> 16                TRUE                TRUE            1.025000 #> 17                TRUE                TRUE            3.333333 #> 18                TRUE                TRUE            1.050725 #> 19                TRUE                TRUE            1.212121 #> 20                TRUE                TRUE            1.055556 #> 21                TRUE                TRUE            1.275720 #> 22                TRUE                TRUE            1.600000 #> 23                TRUE                TRUE            1.130435 #> 24                TRUE                TRUE            1.081081 #> 25                TRUE                TRUE            1.082803 #> 26                TRUE                TRUE            1.182796 #> 27                TRUE                TRUE            1.014994 #> 28                TRUE                TRUE            1.060606 #> 29                TRUE                TRUE            1.666667 #> 30                TRUE                TRUE            1.032258 #> 31                TRUE                TRUE            1.070890 #> 32                TRUE                TRUE            1.165049 #> 33                TRUE                TRUE            1.036269 #>    MinPatch_Proportion #> 1             2.500000 #> 2             1.151515 #> 3             1.851852 #> 4             1.017049 #> 5             1.000468 #> 6             1.032631 #> 7             1.111111 #> 8             1.015697 #> 9             1.585761 #> 10            1.079109 #> 11            1.057692 #> 12            1.151515 #> 13            1.003745 #> 14            1.004902 #> 15            1.105769 #> 16            1.070833 #> 17            3.333333 #> 18            1.014493 #> 19            1.212121 #> 20            1.333333 #> 21            1.522634 #> 22            1.466667 #> 23            1.159420 #> 24            1.081081 #> 25            1.507431 #> 26            1.182796 #> 27            1.003460 #> 28            1.515152 #> 29            1.666667 #> 30            1.005376 #> 31            1.176471 #> 32            1.197411 #> 33            1.001727  # Print summary statistics cat(\"\\n=== Feature Change Summary ===\\n\") #>  #> === Feature Change Summary === print(comparison$summary) #>   features_improved features_reduced features_unchanged targets_gained #> 1                15               12                  6              0 #>   targets_lost #> 1            0"},{"path":"/articles/minpatchTasmania.html","id":"run-different-patch-sizes","dir":"Articles","previous_headings":"","what":"Run different patch sizes","title":"MinPatch in Tasmania","text":"minimum patch size parameter core constraint drives MinPatch behaviour - determines threshold patches considered small must either enlarged removed. Stage 1, MinPatch removes patches smaller threshold (except existing protected areas). Stage 2, adds new patches large enough meet minimum targets unmet. Stage 3 (whittling), prevents removal planning units make patch fall threshold. Larger minimum patch sizes result fewer, bigger patches potentially higher total area, MinPatch must ensure every patch meets size requirement. Smaller minimum patch sizes allow flexibility, potentially resulting patches closer original prioritizr solution. choice minimum patch size reflect ecological management considerations - example, larger patches may needed support viable populations reduce edge effects, smaller patches may acceptable highly connected landscapes features don’t require large contiguous areas.","code":"# Calculate reasonable parameters based on planning unit characteristics median_area <- median(st_area(tas)) min_patch_size <- median_area * 10 patch_radius <- sqrt(median_area * 10)  result2 <- run_minpatch(   prioritizr_problem = p,   prioritizr_solution = s,   min_patch_size = min_patch_size,   patch_radius = patch_radius,   remove_small_patches = TRUE,   add_patches = TRUE,   whittle_patches = TRUE,   verbose = FALSE )   median_area <- median(st_area(tas)) min_patch_size <- median_area * 20 patch_radius <- sqrt(median_area * 10)  result3 <- run_minpatch(   prioritizr_problem = p,   prioritizr_solution = s,   min_patch_size = min_patch_size,   patch_radius = patch_radius,   remove_small_patches = TRUE,   add_patches = TRUE,   whittle_patches = TRUE,   verbose = FALSE )"},{"path":"/articles/minpatchTasmania.html","id":"visualise-the-minpatch-solution-1","dir":"Articles","previous_headings":"Run different patch sizes","what":"Visualise the minpatch solution","title":"MinPatch in Tasmania","text":"","code":"patchwork::wrap_plots(plot_minpatch(result, title = \"Patch Size x5\"),                       plot_minpatch(result2, title = \"Patch Size x10\"),                       plot_minpatch(result3, title = \"Patch Size x20\"),                       guides = \"collect\",                       ncol = 3) &   theme(legend.position = \"bottom\")"},{"path":"/articles/minpatchTasmania.html","id":"run-different-boundary-penalties","dir":"Articles","previous_headings":"","what":"Run different Boundary Penalties","title":"MinPatch in Tasmania","text":"boundary penalty controls much MinPatch prioritizes spatial compactness “simulated whittling” stage. whittling, MinPatch considers removing planning units patch edges, doesn’t increase total priortizr cost. boundary penalty affects decision penalizing fragmented solutions - higher penalties favour compact patches making costly create additional “edge” selected unselected areas. MinPatch evaluates whether remove unit, calculates change boundary length (units selected neighbours increase boundary removed, units unselected neighbours decrease boundary) multiplies boundary penalty. resulting boundary cost change exceeds unit’s cost, unit removed. datasets like Tasmania long planning unit boundaries relative unit costs, even small boundary penalties can highly influential, potentially preventing unit removals resulting similar solutions across different penalty values. small penalties (e.g., 1e-10) may needed see meaningful differences cases.","code":"# Calculate reasonable parameters based on planning unit characteristics median_area <- median(st_area(tas)) min_patch_size <- median_area * 5 patch_radius <- sqrt(median_area * 10)  result4 <- run_minpatch(   prioritizr_problem = p,   prioritizr_solution = s,   min_patch_size = min_patch_size,   patch_radius = patch_radius,   boundary_penalty = 1,   remove_small_patches = TRUE,   add_patches = TRUE,   whittle_patches = TRUE,   verbose = FALSE )   result5 <- run_minpatch(   prioritizr_problem = p,   prioritizr_solution = s,   min_patch_size = min_patch_size,   patch_radius = patch_radius,   boundary_penalty = 10,    remove_small_patches = TRUE,   add_patches = TRUE,   whittle_patches = TRUE,   verbose = FALSE )"},{"path":"/articles/minpatchTasmania.html","id":"visualise-the-final-solution","dir":"Articles","previous_headings":"Run different Boundary Penalties","what":"Visualise the final solution","title":"MinPatch in Tasmania","text":"","code":"patchwork::wrap_plots(plot_prioritizr(result2$solution, col = \"minpatch\", title = \"Boundary Penalty: 0\"),                       plot_prioritizr(result4$solution, col = \"minpatch\", title = \"Boundary Penalty: 1\"),                       plot_prioritizr(result5$solution, col = \"minpatch\", title = \"Boundary Penalty: 10\"),                       guides = \"collect\",                       ncol = 3) &   theme(legend.position = \"bottom\")"},{"path":"/articles/minpatchTasmania.html","id":"visualise-the-differences-in-the-minpatch-solution","dir":"Articles","previous_headings":"Run different Boundary Penalties","what":"Visualise the differences in the minpatch solution","title":"MinPatch in Tasmania","text":"","code":"patchwork::wrap_plots(plot_minpatch(result2, title = \"Boundary Penalty: 0\"),                       plot_minpatch(result4, title = \"Boundary Penalty: 1\"),                       plot_minpatch(result5, title = \"Boundary Penalty: 10\"),                       guides = \"collect\",                       ncol = 3) &   theme(legend.position = \"bottom\")"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jason D. Everett. Author, maintainer. Anthony J. Richardson. Author. Robert J. Smith. Author.           Original MinPatch algorithm author","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Everett J, Richardson , Smith R (2026). minpatch: Post-Processing Conservation Planning Solutions Ensure Minimum Patch Sizes. R package version 0.1.0, https://github.com/SpatialPlanning/minpatch.","code":"@Manual{,   title = {minpatch: Post-Processing for Conservation Planning Solutions to Ensure Minimum Patch Sizes},   author = {Jason D. Everett and Anthony J. Richardson and Robert J. Smith},   year = {2026},   note = {R package version 0.1.0},   url = {https://github.com/SpatialPlanning/minpatch}, }"},{"path":"/index.html","id":"minpatch-for-r","dir":"","previous_headings":"","what":"Post-Processing for Conservation Planning Solutions to Ensure Minimum Patch Sizes","title":"Post-Processing for Conservation Planning Solutions to Ensure Minimum Patch Sizes","text":"Note: still work progress significant bugs may present. Use caution information original implemention MinPatch Marxan QGIS available : https://cluz-systematic-conservation-planning.github.io","code":""},{"path":"/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Post-Processing for Conservation Planning Solutions to Ensure Minimum Patch Sizes","text":"R implementation MinPatch algorithm post-processing conservation planning solutions ensure minimum protected area sizes. MinPatch post-processing tool conservation planning solutions ensures protected areas meet user-defined minimum size thresholds. R package implements methodology described Smith et al. (2010) designed work solutions prioritizr package, though can work binary conservation solution.","code":""},{"path":"/index.html","id":"the-problem","dir":"","previous_headings":"Overview","what":"The Problem","title":"Post-Processing for Conservation Planning Solutions to Ensure Minimum Patch Sizes","text":"Conservation planning software like Marxan prioritizr can produce solutions many small, fragmented protected areas. solutions may mathematically optimal, small protected areas often: Less ecologically viable expensive manage vulnerable edge effects Less resilient disturbances","code":""},{"path":"/index.html","id":"the-solution","dir":"","previous_headings":"Overview","what":"The Solution","title":"Post-Processing for Conservation Planning Solutions to Ensure Minimum Patch Sizes","text":"MinPatch addresses post-processing conservation solutions three stages: Remove Small Patches: Eliminate protected areas smaller minimum size threshold Add New Patches: Add new areas meet conservation targets using BestPatch algorithm Simulated Whittling: Remove unnecessary planning units maintaining constraints","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Post-Processing for Conservation Planning Solutions to Ensure Minimum Patch Sizes","text":"","code":"# Install from GitHub pak::pak(\"SpatialPlanning/minpatch\")"},{"path":"/index.html","id":"key-features","dir":"","previous_headings":"","what":"Key Features","title":"Post-Processing for Conservation Planning Solutions to Ensure Minimum Patch Sizes","text":"Full MinPatch Algorithm: Complete implementation three stages prioritizr Integration: Seamless workflow prioritizr solutions Locked Constraints Support: Automatically respects locked-locked-constraints prioritizr Flexible Parameters: Control minimum patch sizes, patch radius, boundary penalties Comprehensive Reporting: Detailed statistics comparisons Visualization Support: Plot results ggplot2 (optional)","code":""},{"path":[]},{"path":"/index.html","id":"locked-constraints","dir":"","previous_headings":"Algorithm Details","what":"Locked Constraints","title":"Post-Processing for Conservation Planning Solutions to Ensure Minimum Patch Sizes","text":"MinPatch automatically respects locked-locked-constraints prioritizr problems: Locked-constraints (add_locked_in_constraints()): Planning units locked-never removed, regardless patch size whittling stage. units treated “conserved” areas must retained final solution. Locked-constraints (add_locked_out_constraints()): Planning units locked-never selected, even adding new patches meet conservation targets. units completely excluded consideration. locked-units form patches smaller min_patch_size, warning issued, units still preserved solution.","code":""},{"path":"/index.html","id":"stage-1-remove-small-patches","dir":"","previous_headings":"Algorithm Details","what":"Stage 1: Remove Small Patches","title":"Post-Processing for Conservation Planning Solutions to Ensure Minimum Patch Sizes","text":"Identifies connected components (patches) solution removes smaller minimum size threshold. Locked-planning units never removed, even form small patches.","code":""},{"path":"/index.html","id":"stage-2-add-new-patches-bestpatch-algorithm","dir":"","previous_headings":"Algorithm Details","what":"Stage 2: Add New Patches (BestPatch Algorithm)","title":"Post-Processing for Conservation Planning Solutions to Ensure Minimum Patch Sizes","text":"Uses BestPatch scoring system add new patches: Calculate current conservation levels feature Identify features unmet targets Score potential patches based contribution targets relative cost Add highest-scoring patch repeat BestPatch score calculated :","code":"Score = Σ(feature_contribution / target_gap) / patch_cost"},{"path":"/index.html","id":"stage-3-simulated-whittling","dir":"","previous_headings":"Algorithm Details","what":"Stage 3: Simulated Whittling","title":"Post-Processing for Conservation Planning Solutions to Ensure Minimum Patch Sizes","text":"Removes unnecessary planning units iterative process: Identify edge units (boundary selected areas) Calculate whittling scores based feature importance Must cause targets unmet Must make patches small Must increase total cost (boundary penalty > 0) Must split patches non-viable pieces","code":""},{"path":"/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Post-Processing for Conservation Planning Solutions to Ensure Minimum Patch Sizes","text":"use package, please cite original paper implementation:","code":"Smith, R.J., Di Minin, E., Linke, S., Segan, D.B., Possingham, H.P. (2010).  An approach for ensuring minimum protected area size in systematic conservation planning.  Biological Conservation, 143(10), 2525-2531.  Everett J.D., Richardson A.J., Smith R.J. (2025). _minpatch: Post-Processing for Conservation Planning Solutions to Ensure Minimum Patch   Sizes_. R package version 0.1.0, <https://github.com/SpatialPlanning/minpatch>."},{"path":"/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Post-Processing for Conservation Planning Solutions to Ensure Minimum Patch Sizes","text":"GPL (>= 3)","code":""},{"path":"/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Post-Processing for Conservation Planning Solutions to Ensure Minimum Patch Sizes","text":"Smith, R.J., Di Minin, E., Linke, S., Segan, D.B., Possingham, H.P. (2010). approach ensuring minimum protected area size systematic conservation planning. Biological Conservation, 143(10), 2525-2531.","code":""},{"path":"/index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting Help","title":"Post-Processing for Conservation Planning Solutions to Ensure Minimum Patch Sizes","text":"Check package vignette: vignette(\"minpatch\") View function documentation: ?run_minpatch Report bugs: GitHub Issues","code":""},{"path":"/reference/add_new_patches.html","id":null,"dir":"Reference","previous_headings":"","what":"Add new patches to meet conservation targets — add_new_patches","title":"Add new patches to meet conservation targets — add_new_patches","text":"Stage 2 MinPatch: Add new patches using BestPatch algorithm","code":""},{"path":"/reference/add_new_patches.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add new patches to meet conservation targets — add_new_patches","text":"","code":"add_new_patches(minpatch_data, verbose = TRUE)"},{"path":"/reference/add_new_patches.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add new patches to meet conservation targets — add_new_patches","text":"minpatch_data List containing MinPatch data structures (including prioritizr objects) verbose Logical, whether print progress","code":""},{"path":"/reference/add_new_patches.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add new patches to meet conservation targets — add_new_patches","text":"Updated minpatch_data new patches added","code":""},{"path":"/reference/add_patch_centered_on_unit.html","id":null,"dir":"Reference","previous_headings":"","what":"Add patch centered on specified planning unit — add_patch_centered_on_unit","title":"Add patch centered on specified planning unit — add_patch_centered_on_unit","text":"Add patch centered specified planning unit","code":""},{"path":"/reference/add_patch_centered_on_unit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add patch centered on specified planning unit — add_patch_centered_on_unit","text":"","code":"add_patch_centered_on_unit(minpatch_data, center_unit_id)"},{"path":"/reference/add_patch_centered_on_unit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add patch centered on specified planning unit — add_patch_centered_on_unit","text":"minpatch_data List containing MinPatch data structures center_unit_id ID unit center patch ","code":""},{"path":"/reference/add_patch_centered_on_unit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add patch centered on specified planning unit — add_patch_centered_on_unit","text":"Updated unit_dict new patch added","code":""},{"path":"/reference/calculate_best_patch_scores.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate BestPatch scores for all available planning units — calculate_best_patch_scores","title":"Calculate BestPatch scores for all available planning units — calculate_best_patch_scores","text":"Implements BestPatch scoring algorithm original paper","code":""},{"path":"/reference/calculate_best_patch_scores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate BestPatch scores for all available planning units — calculate_best_patch_scores","text":"","code":"calculate_best_patch_scores(minpatch_data, feature_amounts, unmet_targets)"},{"path":"/reference/calculate_best_patch_scores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate BestPatch scores for all available planning units — calculate_best_patch_scores","text":"minpatch_data List containing MinPatch data structures feature_amounts Named vector current conservation amounts unmet_targets Character vector features unmet targets","code":""},{"path":"/reference/calculate_best_patch_scores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate BestPatch scores for all available planning units — calculate_best_patch_scores","text":"Named vector BestPatch scores","code":""},{"path":"/reference/calculate_cost_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate comprehensive cost summary for MinPatch solution — calculate_cost_summary","title":"Calculate comprehensive cost summary for MinPatch solution — calculate_cost_summary","text":"Calculates various cost components using prioritizr functions possible","code":""},{"path":"/reference/calculate_cost_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate comprehensive cost summary for MinPatch solution — calculate_cost_summary","text":"","code":"calculate_cost_summary(minpatch_data)"},{"path":"/reference/calculate_cost_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate comprehensive cost summary for MinPatch solution — calculate_cost_summary","text":"minpatch_data List containing MinPatch data structures","code":""},{"path":"/reference/calculate_cost_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate comprehensive cost summary for MinPatch solution — calculate_cost_summary","text":"List containing detailed cost breakdown","code":""},{"path":"/reference/calculate_feature_conservation.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate current feature conservation amounts — calculate_feature_conservation","title":"Calculate current feature conservation amounts — calculate_feature_conservation","text":"Calculates much feature currently conserved","code":""},{"path":"/reference/calculate_feature_conservation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate current feature conservation amounts — calculate_feature_conservation","text":"","code":"calculate_feature_conservation(minpatch_data)"},{"path":"/reference/calculate_feature_conservation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate current feature conservation amounts — calculate_feature_conservation","text":"minpatch_data List containing MinPatch data structures","code":""},{"path":"/reference/calculate_feature_conservation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate current feature conservation amounts — calculate_feature_conservation","text":"Named vector conserved amounts feature","code":""},{"path":"/reference/calculate_feature_representation.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate feature representation in solution — calculate_feature_representation","title":"Calculate feature representation in solution — calculate_feature_representation","text":"Calculates much conservation feature represented current solution using prioritizr functions possible","code":""},{"path":"/reference/calculate_feature_representation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate feature representation in solution — calculate_feature_representation","text":"","code":"calculate_feature_representation(minpatch_data)"},{"path":"/reference/calculate_feature_representation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate feature representation in solution — calculate_feature_representation","text":"minpatch_data List containing MinPatch data structures including prioritizr objects","code":""},{"path":"/reference/calculate_feature_representation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate feature representation in solution — calculate_feature_representation","text":"Data frame feature representation statistics","code":""},{"path":"/reference/calculate_patch_stats.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate patch statistics — calculate_patch_stats","title":"Calculate patch statistics — calculate_patch_stats","text":"Calculates summary statistics patches including areas counts","code":""},{"path":"/reference/calculate_patch_stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate patch statistics — calculate_patch_stats","text":"","code":"calculate_patch_stats(minpatch_data)"},{"path":"/reference/calculate_patch_stats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate patch statistics — calculate_patch_stats","text":"minpatch_data List containing MinPatch data structures","code":""},{"path":"/reference/calculate_patch_stats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate patch statistics — calculate_patch_stats","text":"Updated minpatch_data patch statistics added","code":""},{"path":"/reference/calculate_whittle_scores.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate whittling scores for edge units — calculate_whittle_scores","title":"Calculate whittling scores for edge units — calculate_whittle_scores","text":"Calculates \"Low Relevance\" score edge unit based feature importance (Equation A2 original paper). Optimized accept pre-computed feature amounts avoid redundant calculations.","code":""},{"path":"/reference/calculate_whittle_scores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate whittling scores for edge units — calculate_whittle_scores","text":"","code":"calculate_whittle_scores(edge_units, minpatch_data, feature_amounts = NULL)"},{"path":"/reference/calculate_whittle_scores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate whittling scores for edge units — calculate_whittle_scores","text":"edge_units Character vector edge unit IDs minpatch_data List containing MinPatch data structures feature_amounts Optional pre-computed feature conservation amounts","code":""},{"path":"/reference/calculate_whittle_scores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate whittling scores for edge units — calculate_whittle_scores","text":"Named vector whittling scores","code":""},{"path":"/reference/can_remove_unit.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if a planning unit can be removed — can_remove_unit","title":"Check if a planning unit can be removed — can_remove_unit","text":"Checks multiple criteria determine removing unit acceptable: 1. violate conservation targets 2. make patch small 3. increase total cost 4. split patches non-viable pieces","code":""},{"path":"/reference/can_remove_unit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if a planning unit can be removed — can_remove_unit","text":"","code":"can_remove_unit(unit_id, minpatch_data, feature_amounts = NULL)"},{"path":"/reference/can_remove_unit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if a planning unit can be removed — can_remove_unit","text":"unit_id ID unit potentially remove minpatch_data List containing MinPatch data structures","code":""},{"path":"/reference/can_remove_unit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if a planning unit can be removed — can_remove_unit","text":"Logical indicating unit can removed","code":""},{"path":"/reference/compare_solutions.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare solutions before and after MinPatch — compare_solutions","title":"Compare solutions before and after MinPatch — compare_solutions","text":"Creates comprehensive comparison key metrics original MinPatch solutions, including overall statistics detailed feature-level analysis","code":""},{"path":"/reference/compare_solutions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare solutions before and after MinPatch — compare_solutions","text":"","code":"compare_solutions(minpatch_result)"},{"path":"/reference/compare_solutions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare solutions before and after MinPatch — compare_solutions","text":"minpatch_result Result run_minpatch function","code":""},{"path":"/reference/compare_solutions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare solutions before and after MinPatch — compare_solutions","text":"List containing: overall: Data frame overall solution comparison features: Data frame feature-level area comparisons summary: List summary statistics feature changes","code":""},{"path":"/reference/compare_solutions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare solutions before and after MinPatch — compare_solutions","text":"","code":"library(prioritizr) library(sf) #> Linking to GEOS 3.13.0, GDAL 3.8.5, PROJ 9.5.1; sf_use_s2() is TRUE library(terra) #> terra 1.8.93  # Get example data from prioritizr dat <- c(get_sim_pu_raster(), get_sim_features()) %>%   as.polygons(dissolve = FALSE, values = TRUE) %>%   sf::st_as_sf() %>%   dplyr::rename(cost = layer)  st_crs(dat) <- NA  features = colnames(dat) %>%   stringr::str_subset(\"feature_\")  # Create prioritizr problem p <- problem(dat, features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.17) %>%  # 17% of each feature   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # Solve problem s <- solve(p)  # Run MinPatch result <- run_minpatch(   prioritizr_problem = p,   prioritizr_solution = s,   min_patch_size = 0.05,   patch_radius = 0.3,   verbose = FALSE )  # Compare solutions comparison <- compare_solutions(result)  # Print overall comparison print(comparison$overall) #>                        Metric Original MinPatch Change Percent_Change #> 1     Selected Planning Units   16.000   20.000  4.000       25.00000 #> 2                  Total Area    0.160    0.200  0.040       25.00000 #> 3           Number of Patches    9.000    6.000 -3.000      -33.33333 #> 4 Valid Patches (>= min size)    0.000    3.000  3.000             NA #> 5           Median Patch Size    0.010    0.035  0.025      250.00000 #> 6          Planning Unit Cost 3964.914 3964.914  0.000        0.00000 #> 7               Boundary Cost    0.000    0.000  0.000             NA #> 8                  Total Cost 3964.914 3964.914  0.000        0.00000  # Print feature-level comparison print(comparison$features) #>   Feature_ID    Target Original_Area MinPatch_Area Area_Change Percent_Change #> 1          1 12.670220     14.083429     17.663862   3.5804329       25.42302 #> 2          2  4.774965      5.124808      5.900540   0.7757315       15.13679 #> 3          3 11.029225     11.707674     14.359023   2.6513489       22.64625 #> 4          4  6.489033      6.863962      8.616472   1.7525103       25.53205 #> 5          5  8.613574      9.482534     12.242924   2.7603903       29.11026 #>   Original_Target_Met MinPatch_Target_Met Original_Proportion #> 1                TRUE                TRUE            1.111538 #> 2                TRUE                TRUE            1.073266 #> 3                TRUE                TRUE            1.061514 #> 4                TRUE                TRUE            1.057779 #> 5                TRUE                TRUE            1.100883 #>   MinPatch_Proportion #> 1            1.394124 #> 2            1.235724 #> 3            1.301907 #> 4            1.327851 #> 5            1.421352  # Print summary statistics cat(\"Features improved:\", comparison$summary$features_improved, \"\\n\") #> Features improved: 5  cat(\"Targets gained:\", comparison$summary$targets_gained, \"\\n\") #> Targets gained: 0"},{"path":"/reference/create_abundance_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Create abundance matrix from planning units — create_abundance_matrix","title":"Create abundance matrix from planning units — create_abundance_matrix","text":"Creates matrix showing amount feature planning unit extracting feature columns directly planning_units using prioritizr problem","code":""},{"path":"/reference/create_abundance_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create abundance matrix from planning units — create_abundance_matrix","text":"","code":"create_abundance_matrix(planning_units, prioritizr_problem)"},{"path":"/reference/create_abundance_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create abundance matrix from planning units — create_abundance_matrix","text":"planning_units sf object planning unit geometries feature columns prioritizr_problem prioritizr problem object get feature names","code":""},{"path":"/reference/create_abundance_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create abundance matrix from planning units — create_abundance_matrix","text":"Named list planning unit contains feature abundances","code":""},{"path":"/reference/create_boundary_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Create boundary matrix from planning units — create_boundary_matrix","title":"Create boundary matrix from planning units — create_boundary_matrix","text":"Creates sparse matrix shared boundary lengths adjacent planning units. Returns Matrix::sparseMatrix efficient storage operations. optimized version supports parallel processing via parallelly package. n_cores = 1, runs sequentially parallel overhead.","code":""},{"path":"/reference/create_boundary_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create boundary matrix from planning units — create_boundary_matrix","text":"","code":"create_boundary_matrix(planning_units, verbose = TRUE, n_cores = NULL)"},{"path":"/reference/create_boundary_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create boundary matrix from planning units — create_boundary_matrix","text":"planning_units sf object planning unit geometries verbose Logical, whether print progress n_cores Integer, number cores use. NULL, uses availableCores(omit=1). Set 1 sequential processing.","code":""},{"path":"/reference/create_boundary_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create boundary matrix from planning units — create_boundary_matrix","text":"Matrix::dgCMatrix sparse matrix [,j] shared boundary length","code":""},{"path":"/reference/create_patch_radius_dict.html","id":null,"dir":"Reference","previous_headings":"","what":"Create patch radius dictionary — create_patch_radius_dict","title":"Create patch radius dictionary — create_patch_radius_dict","text":"planning unit, find units within specified patch radius. Optimized version computes full distance matrix instead n times.","code":""},{"path":"/reference/create_patch_radius_dict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create patch radius dictionary — create_patch_radius_dict","text":"","code":"create_patch_radius_dict(planning_units, patch_radius, verbose = TRUE)"},{"path":"/reference/create_patch_radius_dict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create patch radius dictionary — create_patch_radius_dict","text":"planning_units sf object planning unit geometries patch_radius radius patch creation","code":""},{"path":"/reference/create_patch_radius_dict.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create patch radius dictionary — create_patch_radius_dict","text":"Named list planning unit contains list units within radius","code":""},{"path":"/reference/create_solution_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Create solution vector from unit dictionary — create_solution_vector","title":"Create solution vector from unit dictionary — create_solution_vector","text":"Converts internal unit dictionary back binary solution vector","code":""},{"path":"/reference/create_solution_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create solution vector from unit dictionary — create_solution_vector","text":"","code":"create_solution_vector(unit_dict)"},{"path":"/reference/create_solution_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create solution vector from unit dictionary — create_solution_vector","text":"unit_dict Named list containing cost status planning unit","code":""},{"path":"/reference/create_solution_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create solution vector from unit dictionary — create_solution_vector","text":"Binary numeric vector indicating selected planning units","code":""},{"path":"/reference/extract_locked_in_constraints.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract locked-in constraint indices from prioritizr problem — extract_locked_in_constraints","title":"Extract locked-in constraint indices from prioritizr problem — extract_locked_in_constraints","text":"Extract locked-constraint indices prioritizr problem","code":""},{"path":"/reference/extract_locked_in_constraints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract locked-in constraint indices from prioritizr problem — extract_locked_in_constraints","text":"","code":"extract_locked_in_constraints(prioritizr_problem, verbose = TRUE)"},{"path":"/reference/extract_locked_in_constraints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract locked-in constraint indices from prioritizr problem — extract_locked_in_constraints","text":"prioritizr_problem prioritizr problem object verbose Logical, whether print messages","code":""},{"path":"/reference/extract_locked_in_constraints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract locked-in constraint indices from prioritizr problem — extract_locked_in_constraints","text":"Integer vector locked-planning unit indices","code":""},{"path":"/reference/extract_locked_out_constraints.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract locked-out constraint indices from prioritizr problem — extract_locked_out_constraints","title":"Extract locked-out constraint indices from prioritizr problem — extract_locked_out_constraints","text":"Extract locked-constraint indices prioritizr problem","code":""},{"path":"/reference/extract_locked_out_constraints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract locked-out constraint indices from prioritizr problem — extract_locked_out_constraints","text":"","code":"extract_locked_out_constraints(prioritizr_problem, verbose = TRUE)"},{"path":"/reference/extract_locked_out_constraints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract locked-out constraint indices from prioritizr problem — extract_locked_out_constraints","text":"prioritizr_problem prioritizr problem object verbose Logical, whether print messages","code":""},{"path":"/reference/extract_locked_out_constraints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract locked-out constraint indices from prioritizr problem — extract_locked_out_constraints","text":"Integer vector locked-planning unit indices","code":""},{"path":"/reference/find_edge_units.html","id":null,"dir":"Reference","previous_headings":"","what":"Find edge planning units — find_edge_units","title":"Find edge planning units — find_edge_units","text":"Identifies planning units edge selected areas (least one unselected neighbor). Optimized vector pre-allocation.","code":""},{"path":"/reference/find_edge_units.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find edge planning units — find_edge_units","text":"","code":"find_edge_units(minpatch_data)"},{"path":"/reference/find_edge_units.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find edge planning units — find_edge_units","text":"minpatch_data List containing MinPatch data structures","code":""},{"path":"/reference/find_edge_units.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find edge planning units — find_edge_units","text":"Character vector edge unit IDs","code":""},{"path":"/reference/generate_minpatch_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate comprehensive MinPatch report — generate_minpatch_report","title":"Generate comprehensive MinPatch report — generate_minpatch_report","text":"Creates detailed report MinPatch processing results","code":""},{"path":"/reference/generate_minpatch_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate comprehensive MinPatch report — generate_minpatch_report","text":"","code":"generate_minpatch_report(minpatch_result)"},{"path":"/reference/generate_minpatch_report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate comprehensive MinPatch report — generate_minpatch_report","text":"minpatch_result Result object run_minpatch function","code":""},{"path":"/reference/generate_minpatch_report.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate comprehensive MinPatch report — generate_minpatch_report","text":"List containing formatted report components","code":""},{"path":"/reference/generate_minpatch_report.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate comprehensive MinPatch report — generate_minpatch_report","text":"","code":"library(prioritizr) library(sf) library(terra)  # Get example data from prioritizr dat <- c(get_sim_pu_raster(), get_sim_features()) %>%   as.polygons(dissolve = FALSE, values = TRUE) %>%   sf::st_as_sf() %>%   dplyr::rename(cost = layer)  st_crs(dat) <- NA  features = colnames(dat) %>%   stringr::str_subset(\"feature_\")  # Create prioritizr problem p <- problem(dat, features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.17) %>%  # 17% of each feature   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # Solve problem s <- solve(p)  # Run MinPatch result <- run_minpatch(   prioritizr_problem = p,   prioritizr_solution = s,   min_patch_size = 0.05,   patch_radius = 0.3,   verbose = FALSE )  generate_minpatch_report(result) #> $features #> # A tibble: 5 × 9 #>   feature   met   total_amount absolute_target absolute_held absolute_shortfall #>   <chr>     <lgl>        <dbl>           <dbl>         <dbl>              <dbl> #> 1 feature_1 TRUE          74.5           12.7          17.7                   0 #> 2 feature_2 TRUE          28.1            4.77          5.90                  0 #> 3 feature_3 TRUE          64.9           11.0          14.4                   0 #> 4 feature_4 TRUE          38.2            6.49          8.62                  0 #> 5 feature_5 TRUE          50.7            8.61         12.2                   0 #> # ℹ 3 more variables: relative_target <dbl>, relative_held <dbl>, #> #   relative_shortfall <dbl> #>  #> $patch_stats #>      time all_patch_count all_patch_area median_all_patch valid_patch_count #> 1 initial               9           0.16            0.010                 0 #> 2   final               6           0.20            0.035                 3 #>   valid_patch_area median_valid_patch #> 1             0.00               0.00 #> 2             0.15               0.05 #>  #> $cost #> # A tibble: 1 × 6 #>   summary  cost     n boundary_length boundary_cost total_cost #>   <chr>   <dbl> <dbl>           <dbl>         <dbl>      <dbl> #> 1 overall 3965.    20               0             0      3965. #>"},{"path":"/reference/identify_unmet_targets.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify features with unmet targets — identify_unmet_targets","title":"Identify features with unmet targets — identify_unmet_targets","text":"Uses prioritizr functions identify unmet targets minpatch_data","code":""},{"path":"/reference/identify_unmet_targets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify features with unmet targets — identify_unmet_targets","text":"","code":"identify_unmet_targets(minpatch_data)"},{"path":"/reference/identify_unmet_targets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify features with unmet targets — identify_unmet_targets","text":"minpatch_data List containing MinPatch data structures including prioritizr objects","code":""},{"path":"/reference/identify_unmet_targets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify features with unmet targets — identify_unmet_targets","text":"Character vector feature IDs unmet targets","code":""},{"path":"/reference/initialize_minpatch_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialize MinPatch data structures — initialize_minpatch_data","title":"Initialize MinPatch data structures — initialize_minpatch_data","text":"Creates internal data structures needed MinPatch processing. function extracts locked-locked-constraints prioritizr problem applies status codes: - Status 2 (conserved) locked-units - Status 3 (excluded) locked-units","code":""},{"path":"/reference/initialize_minpatch_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialize MinPatch data structures — initialize_minpatch_data","text":"","code":"initialize_minpatch_data(   solution,   planning_units,   targets,   costs,   min_patch_size,   patch_radius,   boundary_penalty,   prioritizr_problem,   prioritizr_solution,   verbose = TRUE )"},{"path":"/reference/initialize_minpatch_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialize MinPatch data structures — initialize_minpatch_data","text":"solution Binary solution vector planning_units sf object planning units targets data.frame targets costs numeric vector costs min_patch_size minimum patch size patch_radius patch radius boundary_penalty Boundary penalty value prioritizr_problem prioritizr problem object prioritizr_solution solved prioritizr solution object verbose Logical, whether print progress","code":""},{"path":"/reference/initialize_minpatch_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialize MinPatch data structures — initialize_minpatch_data","text":"List containing necessary data structures","code":""},{"path":"/reference/make_minpatch_summary_table.html","id":null,"dir":"Reference","previous_headings":"","what":"Make MinPatch summary table — make_minpatch_summary_table","title":"Make MinPatch summary table — make_minpatch_summary_table","text":"Builds single table summarising baseline solution multiple MinPatch solutions. Baseline patch metrics come `compare_solutions(... )$overall[,\"Original\"]`, MinPatch metrics come `compare_solutions(... )$overall[,\"MinPatch\"]`.","code":""},{"path":"/reference/make_minpatch_summary_table.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make MinPatch summary table — make_minpatch_summary_table","text":"","code":"make_minpatch_summary_table(   region_sf,   baseline_solution_sf,   minpatch_results,   multipliers,   compare_solutions_fun = NULL,   baseline_compare_obj = NULL,   baseline_elapsed = NA_real_,   minpatch_elapsed = NULL,   projected_epsg = 32740,   baseline_solution_col = NULL,   minpatch_solution_col = \"minpatch\",   cost_col = \"cost\",   baseline_boundary_cost = 0,   make_kable = TRUE )"},{"path":"/reference/make_minpatch_summary_table.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make MinPatch summary table — make_minpatch_summary_table","text":"region_sf sf planning units (used compute median PU area min patch size). baseline_solution_sf sf containing baseline solution selection column PU costs. minpatch_results List MinPatch results; must contain `$solution` (sf). multipliers Numeric vector; length/order `minpatch_results`. compare_solutions_fun Function returns list `$overall`. NULL, function try find `compare_solutions()` session. baseline_compare_obj Object pass compare_solutions() baseline \"Original\" metrics. NULL, defaults `minpatch_results[[1]]`. baseline_elapsed Baseline runtime (seconds). Optional. minpatch_elapsed MinPatch runtimes (seconds). Optional; must match `multipliers`. projected_epsg EPSG perimeter calcs inputs lon/lat (default 32740). baseline_solution_col Baseline selection column name (1/0). NULL, auto-detects. minpatch_solution_col MinPatch selection column `$solution` (default \"minpatch\"). cost_col PU cost column `baseline_solution_sf` (default \"cost\"). baseline_boundary_cost Baseline boundary cost (default 0). make_kable TRUE, also returns HTML kable.","code":""},{"path":"/reference/make_minpatch_summary_table.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make MinPatch summary table — make_minpatch_summary_table","text":"list(data = tibble, kable = html NULL)","code":""},{"path":"/reference/make_patch_dict.html","id":null,"dir":"Reference","previous_headings":"","what":"Create patch dictionary from unit dictionary — make_patch_dict","title":"Create patch dictionary from unit dictionary — make_patch_dict","text":"Identifies connected components (patches) current solution using igraph sparse matrix operations. implementation follows wheretowork approach efficient patch identification using matrix subsetting.","code":""},{"path":"/reference/make_patch_dict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create patch dictionary from unit dictionary — make_patch_dict","text":"","code":"make_patch_dict(minpatch_data)"},{"path":"/reference/make_patch_dict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create patch dictionary from unit dictionary — make_patch_dict","text":"minpatch_data List containing MinPatch data structures","code":""},{"path":"/reference/make_patch_dict.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create patch dictionary from unit dictionary — make_patch_dict","text":"Named list patch contains area, unit count, unit IDs","code":""},{"path":"/reference/minpatch-package.html","id":null,"dir":"Reference","previous_headings":"","what":"MinPatch for R: Post-processing prioritizr solutions to ensure minimum patch sizes — minpatch-package","title":"MinPatch for R: Post-processing prioritizr solutions to ensure minimum patch sizes — minpatch-package","text":"package provides functions post-process conservation planning solutions prioritizr ensure protected areas meet user-defined minimum size thresholds, following methodology described Smith et al. (2010).","code":""},{"path":[]},{"path":"/reference/minpatch-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"MinPatch for R: Post-processing prioritizr solutions to ensure minimum patch sizes — minpatch-package","text":"Maintainer: Jason D. Everett DrJasonEverett@gmail.com (ORCID) Authors: Anthony J. Richardson .richardson1@uq.edu.au (ORCID) Robert J. Smith (Original MinPatch algorithm author)","code":""},{"path":"/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling `rhs(lhs)`.","code":""},{"path":"/reference/plot_minpatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize MinPatch results — plot_minpatch","title":"Visualize MinPatch results — plot_minpatch","text":"Creates simple visualization MinPatch results showing original vs. modified solutions","code":""},{"path":"/reference/plot_minpatch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize MinPatch results — plot_minpatch","text":"","code":"plot_minpatch(minpatch_result, title = \"MinPatch Results\")"},{"path":"/reference/plot_minpatch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize MinPatch results — plot_minpatch","text":"minpatch_result Result run_minpatch function title Plot title (optional)","code":""},{"path":"/reference/plot_minpatch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize MinPatch results — plot_minpatch","text":"ggplot object (ggplot2 available)","code":""},{"path":"/reference/plot_minpatch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize MinPatch results — plot_minpatch","text":"","code":"library(prioritizr) library(sf) library(terra)  # Get example data from prioritizr dat <- c(get_sim_pu_raster(), get_sim_features()) %>%   as.polygons(dissolve = FALSE, values = TRUE) %>%   sf::st_as_sf() %>%   dplyr::rename(cost = layer)  st_crs(dat) <- NA  features = colnames(dat) %>%   stringr::str_subset(\"feature_\")  # Create prioritizr problem p <- problem(dat, features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.17) %>%  # 17% of each feature   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # Solve problem s <- solve(p)  # Run MinPatch result <- run_minpatch(   prioritizr_problem = p,   prioritizr_solution = s,   min_patch_size = 0.05,   patch_radius = 0.3,   verbose = FALSE )  # Visualize results plot_minpatch(result)"},{"path":"/reference/plot_patch_validity.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot rook-adjacency patches for a MinPatch solution and flag valid/invalid patches — plot_patch_validity","title":"Plot rook-adjacency patches for a MinPatch solution and flag valid/invalid patches — plot_patch_validity","text":"patch rook-connected cluster selected planning units (edge-sharing). patch \"valid\" area >= (multiplier x median PU area), small numeric tolerance avoid floating-point edge cases.","code":""},{"path":"/reference/plot_patch_validity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot rook-adjacency patches for a MinPatch solution and flag valid/invalid patches — plot_patch_validity","text":"","code":"plot_patch_validity(   multiplier,   multipliers,   minpatch_results,   pu_sf = NULL,   return = c(\"plot\", \"counts\", \"patches\"),   do_snap = TRUE,   snap_size = 1,   eps_rel = 1e-09,   debug = FALSE )"},{"path":"/reference/plot_patch_validity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot rook-adjacency patches for a MinPatch solution and flag valid/invalid patches — plot_patch_validity","text":"multiplier Numeric. MinPatch multiplier plot (must exist `multipliers`). multipliers Numeric vector multipliers (order `minpatch_results`). minpatch_results List. element contains `$solution` sf object column `minpatch`. pu_sf sf. Planning-unit sf used compute median PU area (defaults Seychelles_sf present). return Character. \"plot\" (ggplot), \"counts\" (tibble), \"patches\" (sf patch polygons). do_snap Logical. TRUE, snap geometries adjacency robustness. snap_size Numeric. Grid size passed `lwgeom::st_snap_to_grid()` (CRS units). eps_rel Numeric. Relative tolerance applied area threshold (default 1e-9). debug Logical. TRUE, prints patch table (including diff vs threshold).","code":""},{"path":"/reference/plot_patch_validity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot rook-adjacency patches for a MinPatch solution and flag valid/invalid patches — plot_patch_validity","text":"ggplot object, tibble, sf patch polygons (see `return`).","code":""},{"path":"/reference/plot_prioritizr.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize prioritizr solutions — plot_prioritizr","title":"Visualize prioritizr solutions — plot_prioritizr","text":"Creates simple visualization prioritizr solutions showing selected unselected planning units using ggplot2","code":""},{"path":"/reference/plot_prioritizr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize prioritizr solutions — plot_prioritizr","text":"","code":"plot_prioritizr(s, col = \"solution_1\", title = \"prioritizr Solution\")"},{"path":"/reference/plot_prioritizr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize prioritizr solutions — plot_prioritizr","text":"s sf object containing planning units solution data col Column name containing solution values (default = \"solution_1\") title Plot title (default = \"prioritizr Solution\")","code":""},{"path":"/reference/plot_prioritizr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize prioritizr solutions — plot_prioritizr","text":"ggplot object showing spatial solution","code":""},{"path":"/reference/plot_prioritizr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize prioritizr solutions — plot_prioritizr","text":"","code":"library(prioritizr) library(sf) library(terra)  # Get example data from prioritizr dat <- c(get_sim_pu_raster(), get_sim_features()) %>%   as.polygons(dissolve = FALSE, values = TRUE) %>%   sf::st_as_sf() %>%   dplyr::rename(cost = layer)  st_crs(dat) <- NA  features = colnames(dat) %>%   stringr::str_subset(\"feature_\")  # Create prioritizr problem p <- problem(dat, features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.17) %>%  # 17% of each feature   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # Solve problem s <- solve(p)  # Plot the solution plot_prioritizr(s)   # Plot with custom title and column plot_prioritizr(s, col = \"solution_1\", title = \"My Conservation Plan\")"},{"path":"/reference/plot_solution_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot solution grid across multiple results — plot_solution_grid","title":"Plot solution grid across multiple results — plot_solution_grid","text":"Creates grid prioritizr-style selection maps shared legend. Useful comparing solutions across different boundary penalties MinPatch multipliers.","code":""},{"path":"/reference/plot_solution_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot solution grid across multiple results — plot_solution_grid","text":"","code":"plot_solution_grid(   results,   get_solution_fun,   ncol = 3,   legend_position = \"bottom\",   title_size = 13,   titles = NULL,   title_fun = NULL,   subtitle_values = NULL,   title_prefix = \"\",   value_label_fun = function(x) format(x, scientific = TRUE, trim = TRUE),   include_baseline = FALSE,   baseline_solution = NULL,   baseline_title = NULL )"},{"path":"/reference/plot_solution_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot solution grid across multiple results — plot_solution_grid","text":"results List MinPatch result objects plot get_solution_fun Function extract solution sf object result ncol Number columns grid (default = 3) legend_position Position shared legend (default = \"bottom\") title_size Font size plot titles (default = 13) titles Character vector titles (one per result). Takes priority title options. title_fun Function(, results) returning title string. Used titles NULL. subtitle_values Numeric vector values (e.g., penalties multipliers) titles title_prefix Prefix string subtitle_values titles (e.g., \"Boundary penalty = \") value_label_fun Function format subtitle_values (default formats scientifically) include_baseline Logical, whether include baseline plot (default = FALSE) baseline_solution sf object baseline solution (required include_baseline = TRUE) baseline_title Title baseline plot","code":""},{"path":"/reference/plot_solution_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot solution grid across multiple results — plot_solution_grid","text":"patchwork object combining plots","code":""},{"path":"/reference/print_minpatch_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Print MinPatch results summary — print_minpatch_summary","title":"Print MinPatch results summary — print_minpatch_summary","text":"Prints formatted summary MinPatch processing results","code":""},{"path":"/reference/print_minpatch_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print MinPatch results summary — print_minpatch_summary","text":"","code":"print_minpatch_summary(minpatch_result)"},{"path":"/reference/print_minpatch_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print MinPatch results summary — print_minpatch_summary","text":"minpatch_result Result object run_minpatch function","code":""},{"path":"/reference/print_minpatch_summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print MinPatch results summary — print_minpatch_summary","text":"","code":"library(prioritizr) library(sf) library(terra)  # Get example data from prioritizr dat <- c(get_sim_pu_raster(), get_sim_features()) %>%   as.polygons(dissolve = FALSE, values = TRUE) %>%   sf::st_as_sf() %>%   dplyr::rename(cost = layer)  st_crs(dat) <- NA  features = colnames(dat) %>%   stringr::str_subset(\"feature_\")  # Create prioritizr problem p <- problem(dat, features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.17) %>%  # 17% of each feature   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # Solve problem s <- solve(p)  # Run MinPatch result <- run_minpatch(   prioritizr_problem = p,   prioritizr_solution = s,   min_patch_size = 0.05,   patch_radius = 0.3, ) #> Validating inputs... #> Initializing data structures... #> Calculating boundary matrix (optimized version)... #> Creating patch radius dictionary (optimized)... #> Calculating initial patch statistics... #> Stage 1: Removing small patches... #> Stage 2: Adding new patches... #>   Initial unmet targets: 5  #>   Unmet feature IDs: 1, 2, 3, 4, 5  #>   Iteration 1 - Unmet targets: 5  #>     Found 90 potential patches with scores #>     Best score: 0.001699533 for unit 78  #>     Added patch centered on unit 78  #>   Iteration 2 - Unmet targets: 5  #>     Found 76 potential patches with scores #>     Best score: 0.001651032 for unit 66  #>     Added patch centered on unit 66  #>   All conservation targets are now met! #> Stage 3: Removing unnecessary planning units... #>     Edge units found: 8  #>     Keystone units: 0  #>     New keystone units: 0  #>     Scoreable units: 8  #>     Unit 88 cannot be removed - adding to keystone set #>     Edge units found: 7  #>     Keystone units: 1  #>     New keystone units: 0  #>     Scoreable units: 7  #>     Removed unit 64 at iteration 2  #>     Edge units found: 7  #>     Keystone units: 1  #>     New keystone units: 0  #>     Scoreable units: 7  #>     Removed unit 65 at iteration 3  #>     Edge units found: 9  #>     Keystone units: 1  #>     New keystone units: 0  #>     Scoreable units: 9  #>     Removed unit 66 at iteration 4  #>     Edge units found: 8  #>     Keystone units: 1  #>     New keystone units: 0  #>     Scoreable units: 8  #>     Removed unit 57 at iteration 5  #>     Unit 56 cannot be removed - adding to keystone set #>     Removed unit 47 at iteration 7  #>     Unit 55 cannot be removed - adding to keystone set #>     Unit 63 cannot be removed - adding to keystone set #>     Unit 46 cannot be removed - adding to keystone set #>   No more edge units to consider - terminating #> Calculating final statistics... #> MinPatch processing complete!  print_minpatch_summary(result) #> === MinPatch Processing Summary === #>  #> Patch Statistics: #>   Initial patches: 9 (valid: 0) #>   Final patches: 6 (valid: 3) #>   Area change: 0.04 (25.0%) #>  #> Cost Breakdown: #>   Planning unit cost: 3964.91 #>   Boundary cost: 0.00 #>   Total cost: 3964.91 #>   Selected units: 20 #>  #> Feature Representation: #>   Total features: 5 #>   Targets met: 5 #>   Targets unmet: 0 #>   Mean proportion: 0.227 #>   Total shortfall: 0.00 #>  #>  #> === End Summary ==="},{"path":"/reference/removal_increases_cost.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if removing unit would increase cost — removal_increases_cost","title":"Check if removing unit would increase cost — removal_increases_cost","text":"Check removing unit increase cost","code":""},{"path":"/reference/removal_increases_cost.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if removing unit would increase cost — removal_increases_cost","text":"","code":"removal_increases_cost(unit_id, minpatch_data)"},{"path":"/reference/removal_increases_cost.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if removing unit would increase cost — removal_increases_cost","text":"unit_id ID unit potentially remove minpatch_data List containing MinPatch data structures","code":""},{"path":"/reference/removal_increases_cost.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if removing unit would increase cost — removal_increases_cost","text":"Logical indicating removal increase cost","code":""},{"path":"/reference/removal_increases_marxan_cost.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if removing unit would increase Marxan cost — removal_increases_marxan_cost","title":"Check if removing unit would increase Marxan cost — removal_increases_marxan_cost","text":"Check removing unit increase Marxan cost","code":""},{"path":"/reference/removal_increases_marxan_cost.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if removing unit would increase Marxan cost — removal_increases_marxan_cost","text":"","code":"removal_increases_marxan_cost(unit_id, minpatch_data)"},{"path":"/reference/removal_increases_marxan_cost.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if removing unit would increase Marxan cost — removal_increases_marxan_cost","text":"unit_id ID unit potentially remove minpatch_data List containing MinPatch data structures","code":""},{"path":"/reference/removal_increases_marxan_cost.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if removing unit would increase Marxan cost — removal_increases_marxan_cost","text":"Logical indicating removal increase cost","code":""},{"path":"/reference/removal_makes_patch_too_small.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if removing unit would make its patch too small — removal_makes_patch_too_small","title":"Check if removing unit would make its patch too small — removal_makes_patch_too_small","text":"Check removing unit make patch small","code":""},{"path":"/reference/removal_makes_patch_too_small.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if removing unit would make its patch too small — removal_makes_patch_too_small","text":"","code":"removal_makes_patch_too_small(unit_id, minpatch_data)"},{"path":"/reference/removal_makes_patch_too_small.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if removing unit would make its patch too small — removal_makes_patch_too_small","text":"unit_id ID unit potentially remove minpatch_data List containing MinPatch data structures","code":""},{"path":"/reference/removal_makes_patch_too_small.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if removing unit would make its patch too small — removal_makes_patch_too_small","text":"Logical indicating removal make patch small","code":""},{"path":"/reference/removal_splits_patch_nonviably.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if removing unit would split patch into non-viable pieces — removal_splits_patch_nonviably","title":"Check if removing unit would split patch into non-viable pieces — removal_splits_patch_nonviably","text":"Check removing unit split patch non-viable pieces","code":""},{"path":"/reference/removal_splits_patch_nonviably.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if removing unit would split patch into non-viable pieces — removal_splits_patch_nonviably","text":"","code":"removal_splits_patch_nonviably(unit_id, minpatch_data)"},{"path":"/reference/removal_splits_patch_nonviably.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if removing unit would split patch into non-viable pieces — removal_splits_patch_nonviably","text":"unit_id ID unit potentially remove minpatch_data List containing MinPatch data structures","code":""},{"path":"/reference/removal_splits_patch_nonviably.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if removing unit would split patch into non-viable pieces — removal_splits_patch_nonviably","text":"Logical indicating removal create non-viable patches","code":""},{"path":"/reference/removal_violates_targets.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if removing unit would violate conservation targets — removal_violates_targets","title":"Check if removing unit would violate conservation targets — removal_violates_targets","text":"Optimized accept pre-computed feature amounts avoid redundant calculations.","code":""},{"path":"/reference/removal_violates_targets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if removing unit would violate conservation targets — removal_violates_targets","text":"","code":"removal_violates_targets(unit_id, minpatch_data, feature_amounts = NULL)"},{"path":"/reference/removal_violates_targets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if removing unit would violate conservation targets — removal_violates_targets","text":"unit_id ID unit potentially remove minpatch_data List containing MinPatch data structures feature_amounts Optional pre-computed feature conservation amounts","code":""},{"path":"/reference/removal_violates_targets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if removing unit would violate conservation targets — removal_violates_targets","text":"Logical indicating removal violate targets","code":""},{"path":"/reference/remove_small_patches_from_solution.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove small patches from solution — remove_small_patches_from_solution","title":"Remove small patches from solution — remove_small_patches_from_solution","text":"Stage 1 MinPatch: Remove patches smaller minimum size threshold","code":""},{"path":"/reference/remove_small_patches_from_solution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove small patches from solution — remove_small_patches_from_solution","text":"","code":"remove_small_patches_from_solution(minpatch_data)"},{"path":"/reference/remove_small_patches_from_solution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove small patches from solution — remove_small_patches_from_solution","text":"minpatch_data List containing MinPatch data structures","code":""},{"path":"/reference/remove_small_patches_from_solution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove small patches from solution — remove_small_patches_from_solution","text":"Updated minpatch_data small patches removed","code":""},{"path":"/reference/run_minpatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Run MinPatch algorithm on prioritizr solution — run_minpatch","title":"Run MinPatch algorithm on prioritizr solution — run_minpatch","text":"main function applies MinPatch algorithm prioritizr solution ensure protected areas meet minimum size thresholds. function uses prioritizr summary functions possible reduce code duplication ensure consistency prioritizr calculations.","code":""},{"path":"/reference/run_minpatch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run MinPatch algorithm on prioritizr solution — run_minpatch","text":"","code":"run_minpatch(   prioritizr_problem,   prioritizr_solution,   min_patch_size,   patch_radius,   boundary_penalty = 0,   remove_small_patches = TRUE,   add_patches = TRUE,   whittle_patches = TRUE,   solution_column = \"solution_1\",   verbose = TRUE,   debug_boundary = FALSE,   debug_boundary_every = 50 )"},{"path":"/reference/run_minpatch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run MinPatch algorithm on prioritizr solution — run_minpatch","text":"prioritizr_problem prioritizr problem object prioritizr_solution solved prioritizr solution object min_patch_size Minimum patch size threshold patch_radius Radius adding new patches boundary_penalty Boundary penalty value (default = 0) remove_small_patches Logical, whether remove small patches (Stage 1, default = TRUE) add_patches Logical, whether add new patches meet targets (Stage 2, default = TRUE) whittle_patches Logical, whether remove unnecessary units (Stage 3, default = TRUE) solution_column Name solution column (default = \"solution_1\") verbose Logical, whether print progress (default = TRUE) debug_boundary Logical, whether print boundary cost debug info (default = FALSE) debug_boundary_every Integer, print debug info every N iterations (default = 50)","code":""},{"path":"/reference/run_minpatch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run MinPatch algorithm on prioritizr solution — run_minpatch","text":"MinPatch result object enhanced reporting using prioritizr functions","code":""},{"path":"/reference/run_minpatch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run MinPatch algorithm on prioritizr solution — run_minpatch","text":"MinPatch algorithm consists three stages: Remove small patches: Removes patches smaller min_patch_size Add new patches: Adds patches meet conservation targets Whittle patches: Removes unnecessary planning units **Locked Constraints**: MinPatch automatically respects locked-locked-constraints prioritizr problems (added via add_locked_in_constraints() add_locked_out_constraints()): **Locked-units**: never removed, regardless patch size         whittling. treated \"conserved\" areas must retained. **Locked-units**: never selected, even adding new patches         meet conservation targets. completely excluded consideration. locked-units form patches smaller min_patch_size, warning issued, units still preserved. **Important**: set remove_small_patches = TRUE add_patches = FALSE, algorithm may remove patches without compensating, potentially violating conservation targets. cases, warning issued. Consider using add_patches = TRUE smaller min_patch_size maintain target achievement.","code":""},{"path":"/reference/run_minpatch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run MinPatch algorithm on prioritizr solution — run_minpatch","text":"","code":"library(prioritizr) library(sf) library(terra)  # Get example data from prioritizr dat <- c(get_sim_pu_raster(), get_sim_features()) %>%   as.polygons(dissolve = FALSE, values = TRUE) %>%   sf::st_as_sf() %>%   dplyr::rename(cost = layer)  st_crs(dat) <- NA  features = colnames(dat) %>%   stringr::str_subset(\"feature_\")  # Create prioritizr problem p <- problem(dat, features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.17) %>%  # 17% of each feature   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # Solve problem s <- solve(p)  # Apply MinPatch with all stages result <- run_minpatch(   prioritizr_problem = p,   prioritizr_solution = s,   min_patch_size = 0.05,   patch_radius = 0.3, ) #> Validating inputs... #> Initializing data structures... #> Calculating boundary matrix (optimized version)... #> Creating patch radius dictionary (optimized)... #> Calculating initial patch statistics... #> Stage 1: Removing small patches... #> Stage 2: Adding new patches... #>   Initial unmet targets: 5  #>   Unmet feature IDs: 1, 2, 3, 4, 5  #>   Iteration 1 - Unmet targets: 5  #>     Found 90 potential patches with scores #>     Best score: 0.001699533 for unit 78  #>     Added patch centered on unit 78  #>   Iteration 2 - Unmet targets: 5  #>     Found 76 potential patches with scores #>     Best score: 0.001651032 for unit 66  #>     Added patch centered on unit 66  #>   All conservation targets are now met! #> Stage 3: Removing unnecessary planning units... #>     Edge units found: 8  #>     Keystone units: 0  #>     New keystone units: 0  #>     Scoreable units: 8  #>     Unit 88 cannot be removed - adding to keystone set #>     Edge units found: 7  #>     Keystone units: 1  #>     New keystone units: 0  #>     Scoreable units: 7  #>     Removed unit 64 at iteration 2  #>     Edge units found: 7  #>     Keystone units: 1  #>     New keystone units: 0  #>     Scoreable units: 7  #>     Removed unit 65 at iteration 3  #>     Edge units found: 9  #>     Keystone units: 1  #>     New keystone units: 0  #>     Scoreable units: 9  #>     Removed unit 66 at iteration 4  #>     Edge units found: 8  #>     Keystone units: 1  #>     New keystone units: 0  #>     Scoreable units: 8  #>     Removed unit 57 at iteration 5  #>     Unit 56 cannot be removed - adding to keystone set #>     Removed unit 47 at iteration 7  #>     Unit 55 cannot be removed - adding to keystone set #>     Unit 63 cannot be removed - adding to keystone set #>     Unit 46 cannot be removed - adding to keystone set #>   No more edge units to consider - terminating #> Calculating final statistics... #> MinPatch processing complete!  # Apply MinPatch with only Stage 1 and 3 (skip adding patches) result2 <- run_minpatch(   prioritizr_problem = p,   prioritizr_solution = s,   min_patch_size = 0.05,   patch_radius = 0.3,   add_patches = FALSE ) #> Validating inputs... #> Initializing data structures... #> Calculating boundary matrix (optimized version)... #> Creating patch radius dictionary (optimized)... #> Calculating initial patch statistics... #> Stage 1: Removing small patches... #> Warning: After removing small patches, 5 conservation targets are no longer met. Consider setting add_patches = TRUE to automatically add patches to meet targets, or use a smaller min_patch_size. #>   Warning: 5 targets are no longer met after removing small patches #>   Unmet feature IDs: 1, 2, 3, 4, 5  #> Stage 2: Skipping addition of new patches... #> Stage 3: Removing unnecessary planning units... #>     Edge units found: 0  #>     Keystone units: 0  #>   No more edge units to consider - terminating #> Calculating final statistics... #> MinPatch processing complete!  print_minpatch_summary(result) #> === MinPatch Processing Summary === #>  #> Patch Statistics: #>   Initial patches: 9 (valid: 0) #>   Final patches: 6 (valid: 3) #>   Area change: 0.04 (25.0%) #>  #> Cost Breakdown: #>   Planning unit cost: 3964.91 #>   Boundary cost: 0.00 #>   Total cost: 3964.91 #>   Selected units: 20 #>  #> Feature Representation: #>   Total features: 5 #>   Targets met: 5 #>   Targets unmet: 0 #>   Mean proportion: 0.227 #>   Total shortfall: 0.00 #>  #>  #> === End Summary ==="},{"path":"/reference/simulated_whittling.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated whittling to remove unnecessary planning units — simulated_whittling","title":"Simulated whittling to remove unnecessary planning units — simulated_whittling","text":"Stage 3 MinPatch: Remove planning units needed meet targets, reduce fragmentation, meet minimum patch size requirements","code":""},{"path":"/reference/simulated_whittling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated whittling to remove unnecessary planning units — simulated_whittling","text":"","code":"simulated_whittling(minpatch_data, verbose = TRUE)"},{"path":"/reference/simulated_whittling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulated whittling to remove unnecessary planning units — simulated_whittling","text":"minpatch_data List containing MinPatch data structures (including prioritizr objects) verbose Logical, whether print progress","code":""},{"path":"/reference/simulated_whittling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulated whittling to remove unnecessary planning units — simulated_whittling","text":"Updated minpatch_data unnecessary units removed","code":""},{"path":"/reference/validate_inputs.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate MinPatch inputs — validate_inputs","title":"Validate MinPatch inputs — validate_inputs","text":"Internal function validate inputs MinPatch algorithm, including locked-locked-constraints","code":""},{"path":"/reference/validate_inputs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate MinPatch inputs — validate_inputs","text":"","code":"validate_inputs(   solution,   planning_units,   targets,   costs,   min_patch_size,   patch_radius,   boundary_penalty,   locked_in_indices = NULL,   locked_out_indices = NULL,   area_dict = NULL,   verbose = TRUE )"},{"path":"/reference/validate_inputs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate MinPatch inputs — validate_inputs","text":"solution Binary solution vector planning_units sf object planning units targets data.frame targets costs numeric vector costs min_patch_size minimum patch size patch_radius patch radius adding patches boundary_penalty Boundary penalty value locked_in_indices Optional indices locked-planning units locked_out_indices Optional indices locked-planning units area_dict Optional area dictionary locked-patch size validation verbose Logical, whether print warnings","code":""},{"path":"/reference/validate_inputs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate MinPatch inputs — validate_inputs","text":"NULL (throws errors validation fails)","code":""},{"path":"/reference/visualize_minpatch_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize MinPatch results — plot_minpatch","title":"Visualize MinPatch results — plot_minpatch","text":"Creates simple visualization MinPatch results showing original vs. modified solutions","code":""},{"path":"/reference/visualize_minpatch_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize MinPatch results — plot_minpatch","text":"","code":"plot_minpatch(minpatch_result, title = \"MinPatch Results\")"},{"path":"/reference/visualize_minpatch_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize MinPatch results — plot_minpatch","text":"minpatch_result Result run_minpatch function title Plot title (optional)","code":""},{"path":"/reference/visualize_minpatch_results.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize MinPatch results — plot_minpatch","text":"ggplot object (ggplot2 available)","code":""},{"path":"/reference/visualize_minpatch_results.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize MinPatch results — plot_minpatch","text":"","code":"if (FALSE) { # \\dontrun{ # Requires ggplot2 library(ggplot2)  # Create example data example_data <- create_example_data(n_units = 25, n_features = 3)  # Create prioritizr problem and solve library(prioritizr) p <- problem(example_data$planning_units, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_manual_targets(example_data$targets) %>%   add_binary_decisions() s <- solve(p)  # Run MinPatch result <- run_minpatch(   prioritizr_problem = p,   prioritizr_solution = s,   min_patch_size = 2.0,   patch_radius = 1.5 )  # Visualize results plot <- plot_minpatch(result) print(plot) } # }"}]
