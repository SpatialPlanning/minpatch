---
title: "MinPatch in Tasmania"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{MinPatch in Tasmania}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
```

# Load packages

```{r setup, warning=FALSE, message=FALSE}
#library(minpatch)
devtools::load_all()
library(prioritizr)
library(prioritizrdata)
library(terra)
library(sf)
library(ggplot2)
library(dplyr)
```

# Load data

```{r}
# load data
tas_pu <- get_tas_pu() %>% 
  mutate(cost = cost*10000)

# At present minpatch works with sf objects. Here we convert the data to sf.
tas_features <- get_tas_features() %>% 
  stars::st_as_stars() %>% 
  sf::st_as_sf()

tas <- sf::st_interpolate_aw(tas_features, tas_pu, extensive = FALSE, keep_NA = FALSE, na.rm = FALSE) %>% 
  st_join(tas_pu, join = st_equals)


features = tas %>% 
  sf::st_drop_geometry() %>% 
  dplyr::select(-all_of(c("id", "cost", "locked_in", "locked_out"))) %>% 
  names()

# Convert data to binary again
tas <- tas %>% 
  mutate(across(all_of(features), ~ if_else(.x > 0, 1, 0)))

```

# Run prioritizr analysis

```{r}
p <- problem(tas, features = features, cost_column = "cost") %>%
  add_min_set_objective() %>%
  add_relative_targets(0.30) %>%  # 30% of each feature
  add_binary_decisions() %>%
  add_default_solver(verbose = FALSE)

s <- solve(p)
```

## Plot prioritizr solution

```{r}
plot_prioritizr(s)
```

# MinPatch

## Choose a patch size

```{r}
# Calculate reasonable parameters based on planning unit characteristics
median_area <- median(st_area(tas))

# Set minimum patch size to 5x median planning unit area
min_patch_size <- median_area * 5

# Set patch radius to encompass approximately 10 planning units
patch_radius <- sqrt(median_area * 10)

cat("MinPatch parameters:\n")
cat("- Minimum patch size:", round(min_patch_size, 3), "square meters\n")
cat("- Patch radius:", round(patch_radius,3), "meters\n")
cat("- This means patches must be at least", round(min_patch_size/median_area, 3),
    "times the median planning unit size\n")

```

## Run minpatch

```{r}
result <- run_minpatch(
  prioritizr_problem = p,
  prioritizr_solution = s,
  min_patch_size = min_patch_size,
  patch_radius = patch_radius,
  remove_small_patches = TRUE,
  add_patches = TRUE,
  whittle_patches = TRUE,
  verbose = TRUE
)

```

## Visualise the minpatch solution

```{r}
plot_minpatch(result, title = "MinPatch Results")
```

## Analyse the final results

```{r}
print_minpatch_summary(result)

# Compare original vs MinPatch solutions
comparison <- compare_solutions(result)

# Print overall comparison
cat("=== Overall Solution Comparison ===\n")
print(comparison$overall)

# Print feature-level comparison
cat("\n=== Feature-Level Area Comparison ===\n")
print(comparison$features)

# Print summary statistics
cat("\n=== Feature Change Summary ===\n")
print(comparison$summary)

```

# Run different patch sizes

The minimum patch size parameter is the core constraint that drives MinPatch behaviour - it determines the threshold below which patches are considered too small and must be either enlarged or removed.

-   During Stage 1, MinPatch removes all patches smaller than this threshold (except existing protected areas).
-   During Stage 2, it adds new patches large enough to meet this minimum when targets are unmet.
-   During Stage 3 (whittling), it prevents the removal of planning units that would make any patch fall below this threshold.

Larger minimum patch sizes result in fewer, bigger patches with potentially higher total area, as MinPatch must ensure every patch meets the size requirement. Smaller minimum patch sizes allow more flexibility, potentially resulting in more patches that are closer to the original *prioritizr* solution. The choice of minimum patch size should reflect ecological or management considerations - for example, larger patches may be needed to support viable populations or reduce edge effects, while smaller patches may be acceptable in highly connected landscapes or for features that don't require large contiguous areas.

```{r}
# Calculate reasonable parameters based on planning unit characteristics
median_area <- median(st_area(tas))
min_patch_size <- median_area * 10
patch_radius <- sqrt(median_area * 10)

result2 <- run_minpatch(
  prioritizr_problem = p,
  prioritizr_solution = s,
  min_patch_size = min_patch_size,
  patch_radius = patch_radius,
  remove_small_patches = TRUE,
  add_patches = TRUE,
  whittle_patches = TRUE,
  verbose = FALSE
)


median_area <- median(st_area(tas))
min_patch_size <- median_area * 20
patch_radius <- sqrt(median_area * 10)

result3 <- run_minpatch(
  prioritizr_problem = p,
  prioritizr_solution = s,
  min_patch_size = min_patch_size,
  patch_radius = patch_radius,
  remove_small_patches = TRUE,
  add_patches = TRUE,
  whittle_patches = TRUE,
  verbose = FALSE
)

```

## Visualise the minpatch solution

```{r}
patchwork::wrap_plots(plot_minpatch(result, title = "Patch Size x5"),
                      plot_minpatch(result2, title = "Patch Size x10"),
                      plot_minpatch(result3, title = "Patch Size x20"),
                      guides = "collect",
                      ncol = 3) &
  theme(legend.position = "bottom")
```

# Run different Boundary Penalties

The boundary penalty controls how much MinPatch prioritizes spatial compactness during the "simulated whittling" stage. During whittling, MinPatch considers removing planning units from patch edges, but only if doing so doesn't increase the total *priortizr* cost. The boundary penalty affects this decision by penalizing fragmented solutions - higher penalties favour more compact patches by making it costly to create additional "edge" between selected and unselected areas. When MinPatch evaluates whether to remove a unit, it calculates the change in boundary length (units with selected neighbours increase boundary when removed, while units with unselected neighbours decrease boundary) and multiplies this by the boundary penalty. If the resulting boundary cost change exceeds the unit's cost, the unit cannot be removed. In datasets like Tasmania with long planning unit boundaries relative to unit costs, even small boundary penalties can be highly influential, potentially preventing most unit removals and resulting in similar solutions across different penalty values. Very small penalties (e.g., 1e-10) may be needed to see meaningful differences in such cases.

```{r}
# Calculate reasonable parameters based on planning unit characteristics
median_area <- median(st_area(tas))
min_patch_size <- median_area * 5
patch_radius <- sqrt(median_area * 10)

result4 <- run_minpatch(
  prioritizr_problem = p,
  prioritizr_solution = s,
  min_patch_size = min_patch_size,
  patch_radius = patch_radius,
  boundary_penalty = 1,
  remove_small_patches = TRUE,
  add_patches = TRUE,
  whittle_patches = TRUE,
  verbose = FALSE
)


result5 <- run_minpatch(
  prioritizr_problem = p,
  prioritizr_solution = s,
  min_patch_size = min_patch_size,
  patch_radius = patch_radius,
  boundary_penalty = 10, 
  remove_small_patches = TRUE,
  add_patches = TRUE,
  whittle_patches = TRUE,
  verbose = FALSE
)

```

## Visualise the minpatch solution

```{r}
patchwork::wrap_plots(plot_minpatch(result2, title = "Boundary Penalty: 0"),
                      plot_minpatch(result4, title = "Boundary Penalty: 1"),
                      plot_minpatch(result5, title = "Boundary Penalty: 10"),
                      guides = "collect",
                      ncol = 3) &
  theme(legend.position = "bottom")


boundary_penalties <- c(0, 1, 10)
boundary_results   <- list(result3, result4, result5)

plot_boundary_penalty_grid(
  results = boundary_results,
  penalties = boundary_penalties,
  get_solution_fun = get_solution_with_solution1,
  ncol = 3,
  penalty_label_fun = function(x) format(x, scientific = FALSE, trim = TRUE)
)


```
